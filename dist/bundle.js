/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/HTML.ts":
/*!*********************!*\
  !*** ./src/HTML.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HTML)\n/* harmony export */ });\nclass HTML {\r\n    constructor(state) {\r\n        // toolbar buttons\r\n        this.toolbar = document.getElementById('toolbar');\r\n        this.hideFormsBtn = document.getElementById('hideForms');\r\n        this.playPauseBtn = document.getElementById('playPauseBtn');\r\n        this.fullscreenButton = document.getElementById('fullScreenBtn');\r\n        this.resizeButton = document.getElementById('multiScreenBtn');\r\n        this.muteToggle = document.getElementById('muteBtn');\r\n        // metadata\r\n        this.allTags = [];\r\n        // video players\r\n        this.videoPlayers = [];\r\n        // video forms\r\n        this.videoForms = [];\r\n        // menu\r\n        this.tagsWrappers = [];\r\n        this.state = state;\r\n    }\r\n    createButton(id, content) {\r\n        const btn = document.createElement('button');\r\n        btn.id = id;\r\n        btn.className =\r\n            'toolbar-item';\r\n        btn.style.borderColor = 'rgba(0, 0, 0, 0.4)';\r\n        btn.appendChild(content);\r\n        return btn;\r\n    }\r\n    createSpan(id) {\r\n        const span = document.createElement('span');\r\n        span.id = id;\r\n        span.className = 'text-black-300';\r\n        return span;\r\n    }\r\n    createDiv(id, className = '') {\r\n        const div = document.createElement('div');\r\n        div.id = id;\r\n        div.className = className;\r\n        return div;\r\n    }\r\n    getPositionClass(i) {\r\n        switch (i) {\r\n            case 0:\r\n            case 1:\r\n                return i === 1 ? 'video-layer hidden' : 'video-layer';\r\n            case 2:\r\n            case 3:\r\n                return 'video-layer-right half-size hidden';\r\n            case 4:\r\n            case 5:\r\n                return 'video-layer-botttom half-size hidden';\r\n            case 6:\r\n            case 7:\r\n                return 'video-layer-botttom-right half-size hidden';\r\n            default:\r\n                return 'video-layer hidden';\r\n        }\r\n    }\r\n    svgPlay() {\r\n        return this.createSVG('w-5 h-5', 'M6 4l10 6-10 6V4z');\r\n    }\r\n    svgGrid4() {\r\n        const svg = this.createSVG('w-5 h-5');\r\n        svg.setAttribute('viewBox', '0 0 24 24');\r\n        svg.innerHTML = `\r\n    <rect x=\"4\" y=\"4\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"14\" y=\"4\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"14\" y=\"14\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"4\" y=\"14\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n  `;\r\n        return svg;\r\n    }\r\n    svgPause() {\r\n        return this.createSVG('w-5 h-5', 'M7 4h4v12H7V4zm6 0h4v12h-4V4z');\r\n    }\r\n    svgFullscreen() {\r\n        return this.createSVG('w-4 h-4', 'M4 8V4h4M4 16v4h4M20 8V4h-4M20 16v4h-4', true);\r\n    }\r\n    createSVG(size, d, stroke = false) {\r\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        svg.setAttribute('class', `${size} text-black-300`);\r\n        svg.setAttribute('viewBox', stroke ? '0 0 24 24' : '0 0 20 20');\r\n        if (stroke) {\r\n            svg.setAttribute('fill', 'none');\r\n            svg.setAttribute('stroke', 'currentColor');\r\n            svg.setAttribute('stroke-width', '2');\r\n            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n            path.setAttribute('stroke-linecap', 'round');\r\n            path.setAttribute('stroke-linejoin', 'round');\r\n            path.setAttribute('d', d);\r\n            svg.appendChild(path);\r\n        }\r\n        else if (d) {\r\n            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n            path.setAttribute('fill', 'currentColor');\r\n            path.setAttribute('d', d);\r\n            svg.appendChild(path);\r\n        }\r\n        return svg;\r\n    }\r\n    // togglePlayUI(isPlaying: boolean) {\r\n    //   this.playButton.style.display = isPlaying ? 'none' : 'flex'\r\n    //   this.pauseButton.style.display = isPlaying ? 'flex' : 'none'\r\n    // }\r\n    setMuteIcon(muted) {\r\n        this.muteIcon.innerHTML = muted\r\n            ? `<svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\">\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M18.364 5.636l-12.728 12.728\" />\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M9 9v6l5 4V5l-5 4z\" />\r\n         </svg>`\r\n            : `<svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\">\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n         </svg>`;\r\n    }\r\n    renderTags(container, tags, index, toggleTag) {\r\n        container.innerHTML = ''; // clear previous tags\r\n        const visible = 5;\r\n        const section = Math.floor(index / 2) + 1;\r\n        tags.forEach((tag, i) => {\r\n            const btn = document.createElement('button');\r\n            btn.className = `${tag}-id tag-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition \r\n  hover:bg-white/10 hover:border-gray-400 ${i >= visible ? 'hidden-tag hidden' : ''}`;\r\n            if (this.state.activeTags[section] && this.state.activeTags[section].includes(tag)) {\r\n                btn.classList.add('active-tag'); // mark button active\r\n            }\r\n            btn.textContent = tag;\r\n            btn.addEventListener('click', () => {\r\n                if (toggleTag) {\r\n                    toggleTag(btn);\r\n                }\r\n            });\r\n            container.appendChild(btn);\r\n        });\r\n        if (tags.length > visible) {\r\n            const toggleBtn = document.createElement('button');\r\n            toggleBtn.textContent = 'More';\r\n            toggleBtn.className = 'tag-toggle';\r\n            toggleBtn.onclick = () => {\r\n                container.querySelectorAll('.hidden-tag').forEach(el => el.classList.toggle('hidden'));\r\n            };\r\n            container.appendChild(toggleBtn);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://video-player/./src/HTML.ts?");

/***/ }),

/***/ "./src/Player.ts":
/*!***********************!*\
  !*** ./src/Player.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\r\nclass Players {\r\n    constructor(state, html) {\r\n        this.folder = _config__WEBPACK_IMPORTED_MODULE_0__.config.videoSourcePath;\r\n        this.muted = true;\r\n        this.playerCount = 8;\r\n        this.selectedTags = new Map();\r\n        this.cachedVideos = [];\r\n        this.state = state;\r\n        this.html = html;\r\n        // this.addFormsToPlayers();\r\n    }\r\n    async init() {\r\n        this.active = this.initializeActive(this.playerCount);\r\n        this.html.allTags = await this.fetchAllTags();\r\n        const videoContainer = this.createVideoContainer();\r\n        const rootApp = document.getElementById('app-root');\r\n        rootApp === null || rootApp === void 0 ? void 0 : rootApp.appendChild(videoContainer);\r\n        this.attachEventListeners();\r\n        this.initializeMuteButton();\r\n        await this.loadVideos();\r\n        // this.updateLayout();\r\n        // this.addFormsToPlayers();\r\n    }\r\n    async loadVideos(active = false, reload = false) {\r\n        for (let i = 0; i < this.html.videoPlayers.length; i++) {\r\n            if (!this.state.multiSection && i > 1) {\r\n                continue;\r\n            }\r\n            if (reload && !this.html.videoPlayers[i].src) {\r\n            }\r\n            else if (active && this.active && this.active[i] && this.html.videoPlayers[i].src) {\r\n                continue;\r\n            }\r\n            const section = Math.ceil((i + 1) / 2);\r\n            // get current position for that section\r\n            const pos = this.state.positions[section];\r\n            const playerIndex = i;\r\n            this.html.videoPlayers[playerIndex].src = this.folder + pos + '.mp4';\r\n            this.html.videoPlayers[playerIndex].preload = 'auto';\r\n            const res = await this.getVideoMetadata(pos);\r\n            this.populateMetadataForm(playerIndex, res);\r\n            await this.state.modifyPosition(section);\r\n        }\r\n    }\r\n    async renderSearchResults(videos) {\r\n        const container = document.getElementById('video-container');\r\n        if (!container)\r\n            return;\r\n        if (videos.length === 0) {\r\n            await this.init();\r\n            return;\r\n        }\r\n        container.innerHTML = `\r\n    <div class=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 w-full\">\r\n      ${videos\r\n            .map((v) => {\r\n            var _a;\r\n            const thumbPath = `./videos/thumbnails/${v.id}.jpg`;\r\n            return `\r\n            <div class=\"bg-gray-800 rounded-lg p-2 shadow hover:scale-105 transition-transform\">\r\n              <img src=\"${thumbPath}\" alt=\"${v.title}\" class=\"rounded-md mb-2 w-full\">\r\n              <h3 class=\"text-sm font-semibold truncate\">${v.title}</h3>\r\n              <p class=\"text-xs text-gray-400\">${((_a = v.models) === null || _a === void 0 ? void 0 : _a.map((m) => m.name).join(', ')) || ''}</p>\r\n            </div>\r\n          `;\r\n        })\r\n            .join('')}\r\n    </div>`;\r\n    }\r\n    updateLayout() {\r\n        const isMulti = this.state.multiSection;\r\n        // Always update players 0 and 1\r\n        [0, 1].forEach(index => {\r\n            const player = this.html.videoPlayers[index];\r\n            const wrapper = player.parentElement;\r\n            wrapper.classList.toggle('half-size', isMulti);\r\n        });\r\n        this.html.videoPlayers.forEach((player, index) => {\r\n            if (index < 2)\r\n                return;\r\n            const wrapper = player.parentElement;\r\n            if (!wrapper)\r\n                return;\r\n            // show even-indexed players in multi mode, hide odd ones\r\n            const shouldBeVisible = isMulti ? index % 2 === 0 : index < 2;\r\n            wrapper.classList.toggle('hidden', !shouldBeVisible);\r\n        });\r\n    }\r\n    initializeMuteButton() {\r\n        var _a;\r\n        const muteIcon = document.getElementById('muteIcon');\r\n        // set initial state: all players muted + muted icon\r\n        this.html.videoPlayers.forEach(player => {\r\n            player.muted = this.muted;\r\n        });\r\n        if (muteIcon) {\r\n            muteIcon.innerHTML = `\r\n      <svg class=\"w-4 h-4 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"\r\n        viewBox=\"0 0 24 24\">\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15 9a3 3 0 010 6\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M17.5 7.5a6 6 0 010 9\" />\r\n      </svg>`;\r\n        }\r\n        // add click listener\r\n        (_a = this.html.muteToggle) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => {\r\n            this.muted = !this.muted;\r\n            this.html.videoPlayers.forEach(player => {\r\n                player.muted = this.muted;\r\n            });\r\n        });\r\n    }\r\n    attachEventListeners() {\r\n        this.html.playPauseBtn.addEventListener('click', () => {\r\n            this.html.playPauseBtn.classList.toggle('is-playing');\r\n            this.html.videoPlayers.forEach((player, index) => {\r\n                this.togglePlayPause(index);\r\n            });\r\n        });\r\n        this.html.fullscreenButton.addEventListener('click', () => {\r\n            // Target document.documentElement for the \"Whole Document\"\r\n            const docElm = document.documentElement;\r\n            if (!document.fullscreenElement) {\r\n                docElm.requestFullscreen().catch(err => {\r\n                    console.error(`Error: ${err.message}`);\r\n                });\r\n            }\r\n            else {\r\n                document.exitFullscreen();\r\n            }\r\n        });\r\n        // Update the icon toggle\r\n        document.addEventListener('fullscreenchange', () => {\r\n            this.html.fullscreenButton.classList.toggle('is-fullscreen', !!document.fullscreenElement);\r\n        });\r\n        this.html.resizeButton.addEventListener('click', () => {\r\n            this.html.resizeButton.classList.toggle('is-multi');\r\n            this.state.multiSection = !this.state.multiSection;\r\n            this.updateLayout();\r\n            this.loadVideos(true, true);\r\n        });\r\n        this.html.muteToggle.addEventListener('click', () => {\r\n            this.html.muteToggle.classList.toggle('is-muted');\r\n        });\r\n        this.html.hideFormsBtn.addEventListener('click', () => {\r\n            const forms = document.querySelectorAll('.metadata-form');\r\n            forms.forEach(el => el.classList.toggle('hidden'));\r\n        });\r\n        // searchInput.addEventListener('input', async (e) => {\r\n        //     const value = (e.target as HTMLInputElement).value.trim()\r\n        //     await this.fetchVideos(value)\r\n        //         .then((videos) => this.renderSearchResults(videos))\r\n        //         .catch(console.error)\r\n        // })\r\n        this.html.videoPlayers.forEach((player, index) => {\r\n            player.addEventListener('ended', () => {\r\n                this.handlePlayerEnded(index);\r\n            });\r\n            player.addEventListener('click', () => this.togglePlayPause(index));\r\n        });\r\n    }\r\n    initializeActive(playerCount) {\r\n        const act = {};\r\n        for (let i = 0; i < playerCount; i++) {\r\n            act[i] = (i % 2 === 0);\r\n        }\r\n        return act;\r\n    }\r\n    async getVideoMetadata(videoId) {\r\n        try {\r\n            const response = await fetch(`${this.state.apiUrl}`);\r\n            if (!response.ok)\r\n                throw new Error(`Failed to fetch metadata for videoId ${videoId}`);\r\n            return await response.json();\r\n        }\r\n        catch (error) {\r\n            console.error(`Error fetching metadata for videoId ${videoId}:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    async handlePlayerEnded(playerIndex) {\r\n        try {\r\n            const section = Math.ceil((playerIndex + 1) / 2);\r\n            // flip 0â†”1, 2â†”3, 4â†”5, 6â†”7\r\n            const nextPlayerIndex = playerIndex % 2 === 0 ? playerIndex + 1 : playerIndex - 1;\r\n            const primary = this.html.videoPlayers[playerIndex];\r\n            const secondary = this.html.videoPlayers[nextPlayerIndex];\r\n            if (!primary || !secondary) {\r\n                console.error(`Invalid player index: ${playerIndex}`);\r\n                return;\r\n            }\r\n            await secondary.play();\r\n            this.state.modifyPosition(section);\r\n            // hide/show wrappers instead of videos\r\n            const currentWrapper = primary.parentElement;\r\n            const nextWrapper = secondary.parentElement;\r\n            nextWrapper.classList.remove(\"hidden\");\r\n            currentWrapper.classList.add(\"hidden\");\r\n            // ensure active map exists, then toggle active states correctly (no +1 offset)\r\n            if (!this.active) {\r\n                this.active = this.initializeActive(this.playerCount);\r\n            }\r\n            this.active[nextPlayerIndex] = true;\r\n            this.active[playerIndex] = false;\r\n            const pos = this.state.positions[section];\r\n            const filename = `${this.folder}${pos}.mp4`;\r\n            primary.src = filename;\r\n            primary.preload = \"auto\";\r\n            const res = await this.getVideoMetadata(pos);\r\n            this.populateMetadataForm(playerIndex, res);\r\n            // primary.load();\r\n        }\r\n        catch (err) {\r\n            console.error(`Error in section , player ${playerIndex}:`, err);\r\n        }\r\n    }\r\n    async togglePlayPause(index) {\r\n        const player = this.html.videoPlayers[index];\r\n        const section = Math.floor(index / 2 + 1);\r\n        if (this.active && this.active[index] && !this.state.playing[section]) {\r\n            await player.play();\r\n            console.log(\"starting to play video index\", index);\r\n            const pair = index % 2 === 0 ? index + 1 : index - 1;\r\n            if (this.html.videoForms[pair] && this.state.advancedMode) {\r\n                this.html.videoForms[pair].classList.add('hidden');\r\n            }\r\n            this.state.playing[section] = true;\r\n        }\r\n        else {\r\n            await player.pause();\r\n            console.log(\"pausing video index\", index);\r\n            this.state.playing[section] = false;\r\n        }\r\n        // this.html.toolbar.classList.toggle('hidden');\r\n    }\r\n    populateMetadataForm(index, data) {\r\n        if (!this.isMetadataValid(data) || !data) {\r\n            console.warn(`Invalid or empty metadata for Player ${index}`);\r\n            return;\r\n        }\r\n        const form = document.getElementById(`metaForm${index + 1}`);\r\n        if (!form)\r\n            return;\r\n        const inputs = form.querySelectorAll('input');\r\n        inputs.forEach((input) => {\r\n            switch (input.placeholder) {\r\n                case 'Title':\r\n                    input.value = data.title || '';\r\n                    break;\r\n                case 'Models':\r\n                    input.value = Array.isArray(data.models) ? data.models.join(', ') : (data.models || '');\r\n                    break;\r\n                case 'Studio':\r\n                    input.value = data.studio || '';\r\n                    break;\r\n            }\r\n        });\r\n        if (!data.tags || data.tags.length === 0) {\r\n            return;\r\n        }\r\n        const tagsWrapper = this.html.tagsWrappers[index];\r\n        if (!tagsWrapper)\r\n            return;\r\n        // render toggleable tags directly here\r\n        this.html.renderTags(tagsWrapper, data.tags.map(t => t.title), index, this.toggleTag.bind(this));\r\n    }\r\n    async toggleTag(btn) {\r\n        var _a;\r\n        const tag = (_a = btn.textContent) === null || _a === void 0 ? void 0 : _a.trim();\r\n        if (!tag)\r\n            return;\r\n        const tagClass = `${tag}-id`;\r\n        const sectionEl = btn.closest('[id^=\"player\"]');\r\n        if (!sectionEl)\r\n            throw new Error(`Section element not found for tag \"${tag}\"`);\r\n        // toggle active-tag class for all matching elements in the same section\r\n        const isActive = btn.classList.toggle('active-tag');\r\n        sectionEl.querySelectorAll(`.${tagClass}`).forEach(el => {\r\n            if (el !== btn)\r\n                el.classList.toggle('active-tag', isActive);\r\n        });\r\n        // extract player number (e.g. player3 â†’ 3)\r\n        const playerId = sectionEl.id.match(/\\d+/);\r\n        if (!playerId)\r\n            return;\r\n        const playerNumber = parseInt(playerId[0], 10);\r\n        const section = Math.floor(playerNumber / 2 + 1);\r\n        const tags = this.state.activeTags[section];\r\n        // sync tag state\r\n        if (isActive) {\r\n            if (!tags.includes(tag))\r\n                tags.push(tag);\r\n        }\r\n        else {\r\n            this.state.activeTags[section] = tags.filter(t => t !== tag);\r\n        }\r\n        await this.loadVideos(true);\r\n    }\r\n    async fetchAllTags() {\r\n        try {\r\n            const response = await fetch(`${this.state.apiUrl}/tags`, {\r\n                method: 'GET',\r\n                headers: { 'Content-Type': 'application/json' },\r\n            });\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            const tags = await response.json();\r\n            const sorted = tags.map((t) => (Object.assign({}, t)))\r\n                .sort((a, b) => a.title.localeCompare(b.title, undefined, { sensitivity: 'base' }));\r\n            return sorted; // array of tag objects\r\n        }\r\n        catch (error) {\r\n            console.error('Failed to fetch tags:', error);\r\n            return [];\r\n        }\r\n    }\r\n    isMetadataValid(data) {\r\n        var _a, _b;\r\n        if (!data)\r\n            return false;\r\n        const hasTitle = !!((_a = data.title) === null || _a === void 0 ? void 0 : _a.trim());\r\n        const hasModels = Array.isArray(data.models) && data.models.length > 0;\r\n        const hasStudio = !!((_b = data.studio) === null || _b === void 0 ? void 0 : _b.trim());\r\n        const hasTags = Array.isArray(data.tags) && data.tags.length > 0;\r\n        return hasTitle || hasModels || hasStudio || hasTags;\r\n    }\r\n    async fetchVideos(query) {\r\n        // if query empty and cache exists, use it\r\n        if (!query && this.cachedVideos.length)\r\n            return this.cachedVideos;\r\n        const url = query ? `${this.state.apiUrl}/videos?search=${encodeURIComponent(query)}` : `${this.state.apiUrl}/videos`;\r\n        const res = await fetch(url);\r\n        if (!res.ok)\r\n            throw new Error('Failed to fetch videos');\r\n        const data = await res.json();\r\n        if (!query)\r\n            this.cachedVideos = data; // cache all videos\r\n        return data;\r\n    }\r\n    createMetadataForm(index) {\r\n        // ðŸ’¡ UPDATED: Added positioning classes 'absolute top-0 left-0 z-20 relative'.\r\n        // 'absolute top-0 left-0' places it in the top-left of the parent.\r\n        // 'relative' is crucial for the internal dropdowns (tagListDropdown, uploadFormWrapper) to position correctly relative to the form.\r\n        this.html.videoForms[index] = this.html.createDiv(`metaForm${index}`, 'metadata-form hidden p-2');\r\n        const shouldHide = this.state.playing[Math.floor(index / 2 + 1)];\r\n        if (shouldHide) {\r\n            this.html.videoForms[index].classList.add('hidden');\r\n        }\r\n        const makeInput = (placeholder, key) => {\r\n            const input = document.createElement('input');\r\n            input.type = 'text';\r\n            input.placeholder = placeholder;\r\n            input.className = 'input-fields';\r\n            input.addEventListener('input', async (event) => {\r\n                event.preventDefault();\r\n                await this.updateMeta(index, key, input.value);\r\n            });\r\n            return input;\r\n        };\r\n        const titleInput = makeInput('Title', 'title');\r\n        const modelInput = makeInput('Models', 'models'); // or 'model' if that is your key\r\n        const studioInput = makeInput('Studio', 'studio');\r\n        const tagsWrapper = this.html.createDiv(`tags${index}`, 'tag-container');\r\n        // in your constructor or before usage\r\n        this.html.tagsWrappers.push(tagsWrapper);\r\n        // 1. Create a container for the button and the dropdown\r\n        const tagButtonWrapper = this.html.createDiv('tag-button-wrapper', 'relative inline-block'); // Make this wrapper relative\r\n        // + Button to show available tags\r\n        const addTagBtn = document.createElement('button');\r\n        addTagBtn.type = 'button';\r\n        addTagBtn.textContent = '+';\r\n        addTagBtn.className = 'plus-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition hover:bg-white/10 hover:border-gray-400';\r\n        // 2. Adjust dropdown classes to position relative to the new wrapper\r\n        const tagListDropdown = document.createElement('div');\r\n        tagListDropdown.className = 'tag-list hidden';\r\n        this.html.allTags.forEach((tag) => {\r\n            const tagItem = document.createElement('div');\r\n            tagItem.textContent = tag.title;\r\n            tagItem.className = 'px-3 py-2 hover:bg-gray-200 cursor-pointer';\r\n            tagItem.addEventListener('click', async () => {\r\n                const video = await this.updateMeta(index, 'tag', tag.title, tag.id);\r\n                tagListDropdown.classList.add('hidden'); // hide dropdown\r\n                this.populateMetadataForm((index), video);\r\n            });\r\n            tagListDropdown.appendChild(tagItem);\r\n        });\r\n        // Toggle tag dropdown visibility\r\n        addTagBtn.addEventListener('click', () => {\r\n            tagListDropdown.classList.toggle('hidden');\r\n        });\r\n        // UPLOAD button + form\r\n        const uploadBtn = document.createElement('button');\r\n        uploadBtn.type = 'button';\r\n        uploadBtn.innerHTML = 'ðŸ“¤'; // could be replaced with an icon <svg> if you want\r\n        uploadBtn.className = 'upload-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition hover:bg-white/10 hover:border-gray-400';\r\n        const uploadFormWrapper = document.createElement('div');\r\n        // The dropdowns are already set to absolute, which now uses the form (relative) as its context.\r\n        uploadFormWrapper.className = 'upload-form hidden mt-2 bg-white text-black border border-gray-300 rounded shadow-md p-2 absolute';\r\n        uploadFormWrapper.style.minWidth = '14rem';\r\n        // form fields inside upload form\r\n        const fileInput = document.createElement('input');\r\n        fileInput.type = 'file';\r\n        fileInput.multiple = true;\r\n        fileInput.className = 'block w-full mb-2';\r\n        const uploadTitleInput = document.createElement('input');\r\n        uploadTitleInput.type = 'text';\r\n        uploadTitleInput.placeholder = 'Title';\r\n        uploadTitleInput.className = 'block w-full mb-2 border border-gray-400 px-2 py-1 rounded';\r\n        // tag select for uploaded video\r\n        const uploadTagSelect = document.createElement('select');\r\n        uploadTagSelect.className = 'block w-full mb-2 border border-gray-400 px-2 py-1 rounded';\r\n        this.html.allTags.forEach((tag) => {\r\n            const opt = document.createElement('option');\r\n            opt.value = tag.id.toString();\r\n            opt.textContent = tag.title;\r\n            uploadTagSelect.appendChild(opt);\r\n        });\r\n        const submitUploadBtn = document.createElement('button');\r\n        submitUploadBtn.type = 'button';\r\n        submitUploadBtn.textContent = 'Upload';\r\n        submitUploadBtn.className = 'px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700';\r\n        submitUploadBtn.addEventListener('click', async () => {\r\n            var _a;\r\n            if (!((_a = fileInput.files) === null || _a === void 0 ? void 0 : _a.length))\r\n                return alert('Please select a file.');\r\n            const formData = new FormData();\r\n            // append all selected files\r\n            Array.from(fileInput.files).forEach((file) => {\r\n                formData.append('files', file);\r\n            });\r\n            formData.append('title', uploadTitleInput.value);\r\n            formData.append('tagId', uploadTagSelect.value);\r\n            const res = await fetch(`${this.state.apiUrl}/upload-video`, {\r\n                method: 'POST',\r\n                body: formData,\r\n            });\r\n            if (res.ok) {\r\n                alert('Upload successful');\r\n                uploadFormWrapper.classList.add('hidden');\r\n            }\r\n            else {\r\n                alert('Upload failed');\r\n            }\r\n        });\r\n        uploadFormWrapper.append(fileInput, uploadTitleInput, uploadTagSelect, submitUploadBtn);\r\n        uploadBtn.addEventListener('click', () => {\r\n            uploadFormWrapper.classList.toggle('hidden');\r\n        });\r\n        // Append button and dropdown to the new wrapper\r\n        tagButtonWrapper.append(addTagBtn, tagListDropdown);\r\n        this.html.videoForms[index].append(titleInput, modelInput, studioInput, tagsWrapper, tagButtonWrapper, uploadBtn, uploadFormWrapper);\r\n    }\r\n    async updateMeta(index, key, value, tagId) {\r\n        // gather data to send, assuming you have videos in an array like this:\r\n        const video = this.html.videoPlayers[index];\r\n        if (!video) {\r\n            console.error(`Video player for index ${index} not found`);\r\n            return null;\r\n        }\r\n        const src = video.src;\r\n        if (!src) {\r\n            console.error(`Video source for player at index ${index} is missing`);\r\n            return null;\r\n        }\r\n        const filename = src.split('/').pop();\r\n        if (!filename) {\r\n            console.error(`Could not extract filename from src for video at index ${index}`);\r\n            return null;\r\n        }\r\n        const videoId = filename.replace('.mp4', '');\r\n        if (!videoId) {\r\n            console.error(`Extracted video ID is empty for video at index ${index}`);\r\n            return null;\r\n        }\r\n        const body = { id: videoId };\r\n        // build request body dynamically\r\n        if (key === 'title') {\r\n            body.title = value;\r\n        }\r\n        else if (key === 'models') {\r\n            body.models = value;\r\n        }\r\n        else if (key === 'studio') {\r\n            body.studio = value;\r\n        }\r\n        else if (key === 'tag') {\r\n            body.tag = { id: tagId, title: value };\r\n        }\r\n        try {\r\n            const response = await fetch(`${this.state.apiUrl}/videos`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify(body),\r\n            });\r\n            if (!response.ok) {\r\n                console.error(`HTTP error! status: ${response.status}`);\r\n                return null;\r\n            }\r\n            // After updating, fetch the latest metadata for this video and return it\r\n            const updated = await this.getVideoMetadata(Number(videoId));\r\n            return updated;\r\n        }\r\n        catch (error) {\r\n            console.error(`Failed to update metadata for video ${index}:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    createVideoContainer() {\r\n        const container = document.getElementById('video-container');\r\n        if (!container) {\r\n            throw new Error('Video container element not found');\r\n        }\r\n        this.html.videoPlayers = [];\r\n        for (let i = 0; i <= 7; i++) {\r\n            // ðŸ’¡ UPDATED: Added 'relative' to the wrapper's class list\r\n            const wrapper = this.html.createDiv(`player${i}`, `${this.html.getPositionClass(i)}`);\r\n            this.createMetadataForm(i);\r\n            // Since wrapper is the parent, and the form is absolute, it will now sit in the top-left of this wrapper.\r\n            wrapper.appendChild(this.html.videoForms[i]);\r\n            const video = document.createElement('video');\r\n            video.id = `videoPlayer${i}`;\r\n            video.className = 'video-layer';\r\n            video.muted = true;\r\n            wrapper.appendChild(video);\r\n            container.appendChild(wrapper);\r\n            this.html.videoPlayers.push(video);\r\n        }\r\n        return container;\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Players);\r\n\n\n//# sourceURL=webpack://video-player/./src/Player.ts?");

/***/ }),

/***/ "./src/State.ts":
/*!**********************!*\
  !*** ./src/State.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\r\nclass State {\r\n    constructor() {\r\n        this.multiSection = false; // Whether to use multiple sections\r\n        this.randomized = true;\r\n        this.percentChance = 25; // 25% chance to modify position\r\n        this.endIndex = _config__WEBPACK_IMPORTED_MODULE_0__.config.defaultEndIndex; // Maximum position index\r\n        this.positions = {\r\n            1: this.randomized ? this.randomInRange(1, this.endIndex * 0.25) : 1,\r\n            2: this.randomized ? this.randomInRange(this.endIndex * 0.25, this.endIndex * 0.5) : 500,\r\n            3: this.randomized ? this.randomInRange(this.endIndex * 0.5, this.endIndex * 0.75) : 1000,\r\n            4: this.randomized ? this.randomInRange(this.endIndex * 0.75, this.endIndex) : 1500\r\n        };\r\n        this.activeTags = {\r\n            1: [\"\"],\r\n            2: [\"\"],\r\n            3: [\"\"],\r\n            4: [\"\"]\r\n        };\r\n        this.playing = {\r\n            1: false,\r\n            2: false,\r\n            3: false,\r\n            4: false\r\n        };\r\n        this.apiUrl = _config__WEBPACK_IMPORTED_MODULE_0__.config.apiUrl;\r\n        this.advancedMode = false;\r\n        // Read all URL parameters\r\n        const params = new URLSearchParams(window.location.search);\r\n        // Example: get ?name=Artur\r\n        const name = params.get(\"tags\");\r\n        this.activeTags[1] = name ? name.split(\",\") : [\"\"];\r\n    }\r\n    async modifyPosition(section) {\r\n        var _a;\r\n        if (!(section in this.positions)) {\r\n            throw new Error(`Invalid section: ${section}`);\r\n        }\r\n        // \r\n        const taggedVideos = (_a = (await this.fetchVideosByTags(section))) !== null && _a !== void 0 ? _a : [];\r\n        // Tagged mode\r\n        if (taggedVideos.length > 0) {\r\n            const currentId = this.positions[section];\r\n            const videoIds = taggedVideos.map(v => v.id);\r\n            // Random within tagged\r\n            if (this.randomized) {\r\n                const roll = Math.random() * 100;\r\n                if (roll < this.percentChance) {\r\n                    // pick random from taggedVideos\r\n                    const randomVideo = taggedVideos[Math.floor(Math.random() * taggedVideos.length)];\r\n                    this.positions[section] = randomVideo.id;\r\n                    console.log(\"assigning random position:\", this.positions[section]);\r\n                    return;\r\n                }\r\n            }\r\n            let currentIndex = videoIds.indexOf(currentId);\r\n            if (currentIndex === -1) {\r\n                // Video is last in tagged list or not found, reset to first tagged video\r\n                this.positions[section] = videoIds[0];\r\n                console.log(\"Reseting video:\", this.positions[section]);\r\n                return;\r\n            }\r\n            this.positions[section] = videoIds[currentIndex + 1];\r\n            console.log(\"Quing next video:\", this.positions[section]);\r\n            return;\r\n        }\r\n        // Untagged mode\r\n        if (this.randomized) {\r\n            const roll = Math.random() * 100;\r\n            if (roll < this.percentChance) {\r\n                const newIndex = Math.floor(Math.random() * this.endIndex) + 1;\r\n                this.positions[section] = newIndex;\r\n                return;\r\n            }\r\n        }\r\n        const nextValue = this.positions[section] + 1 > this.endIndex ? 1 : this.positions[section] + 1;\r\n        // Default increment\r\n        this.positions[section] = nextValue;\r\n        return;\r\n    }\r\n    async fetchVideosByTags(section) {\r\n        const tags = this.activeTags[section];\r\n        if (!tags || tags.length === 0)\r\n            return null;\r\n        try {\r\n            const response = await fetch(`${this.apiUrl}/videos/by-tags`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({ tags }),\r\n            });\r\n            if (!response.ok)\r\n                throw new Error(`Server error (${response.status})`);\r\n            const videos = await response.json();\r\n            return videos;\r\n        }\r\n        catch (err) {\r\n            console.error(`Failed to fetch videos for section ${section} with tags ${tags}`, err);\r\n            return null;\r\n        }\r\n    }\r\n    randomInRange(min, max) {\r\n        const minInt = Math.floor(min);\r\n        const maxInt = Math.floor(max);\r\n        return Math.floor(Math.random() * (maxInt - minInt + 1)) + minInt;\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (State);\r\n\n\n//# sourceURL=webpack://video-player/./src/State.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config)\n/* harmony export */ });\n// Detect environment based on the URL in the browser\r\n// If 'window' is undefined (like during SSR), it defaults to localhost\r\nconst isBrowser = typeof window !== 'undefined';\r\nconst isProduction = isBrowser && (window.location.hostname === 'clip-flip.com' || window.location.hostname === 'www.clip-flip.com');\r\nconsole.log(`Running in ${isProduction ? 'production' : 'development'} mode`);\r\nconsole.log(window.location.hostname);\r\nconst config = {\r\n    // If Linux (EC2), use the production domain. If Windows, use localhost.\r\n    baseUrl: isProduction ? 'https://clip-flip.com' : 'http://localhost:3000',\r\n    videoSourcePath: isProduction ? './video/' : './videos/',\r\n    defaultPercentChance: 25,\r\n    defaultEndIndex: 5609,\r\n    apiUrl: isProduction ? 'https://clip-flip.com/api' : 'http://localhost:3000'\r\n};\r\n\n\n//# sourceURL=webpack://video-player/./src/config.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State */ \"./src/State.ts\");\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Player */ \"./src/Player.ts\");\n/* harmony import */ var _HTML__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HTML */ \"./src/HTML.ts\");\n\r\n\r\n\r\ndocument.addEventListener('DOMContentLoaded', async (e) => {\r\n    e.preventDefault();\r\n    const state = new _State__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const html = new _HTML__WEBPACK_IMPORTED_MODULE_2__[\"default\"](state);\r\n    const players = new _Player__WEBPACK_IMPORTED_MODULE_1__[\"default\"](state, html);\r\n    await players.init();\r\n    // expose for debugging or external access\r\n    window.html = html;\r\n    window.state = state;\r\n    window.players = players;\r\n});\r\n\n\n//# sourceURL=webpack://video-player/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;