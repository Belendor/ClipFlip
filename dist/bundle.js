/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/HTML.ts":
/*!*********************!*\
  !*** ./src/HTML.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HTML)\n/* harmony export */ });\nclass HTML {\r\n    constructor(state) {\r\n        // metadata\r\n        this.allTags = [];\r\n        // video players\r\n        this.videoPlayers = [];\r\n        // menu\r\n        this.tagsWrappers = [];\r\n        this.state = state;\r\n    }\r\n    createButton(id, content) {\r\n        const btn = document.createElement('button');\r\n        btn.id = id;\r\n        btn.className =\r\n            'w-8 h-8 rounded border-2 bg-transparent flex items-center justify-center hover:bg-black/10 transition';\r\n        btn.style.borderColor = 'rgba(0, 0, 0, 0.4)';\r\n        btn.appendChild(content);\r\n        return btn;\r\n    }\r\n    createSpan(id) {\r\n        const span = document.createElement('span');\r\n        span.id = id;\r\n        span.className = 'text-black-300';\r\n        return span;\r\n    }\r\n    createDiv(id, className = '') {\r\n        const div = document.createElement('div');\r\n        div.id = id;\r\n        div.className = className;\r\n        return div;\r\n    }\r\n    getPositionClass(i) {\r\n        switch (i) {\r\n            case 0:\r\n            case 1:\r\n                return i === 1 ? 'video-layer hidden' : 'video-layer';\r\n            case 2:\r\n            case 3:\r\n                return 'video-layer-right half-size hidden';\r\n            case 4:\r\n            case 5:\r\n                return 'video-layer-botttom half-size hidden';\r\n            case 6:\r\n            case 7:\r\n                return 'video-layer-botttom-right half-size hidden';\r\n            default:\r\n                return 'video-layer hidden';\r\n        }\r\n    }\r\n    svgPlay() {\r\n        return this.createSVG('w-5 h-5', 'M6 4l10 6-10 6V4z');\r\n    }\r\n    svgGrid4() {\r\n        const svg = this.createSVG('w-5 h-5');\r\n        svg.setAttribute('viewBox', '0 0 24 24');\r\n        svg.innerHTML = `\r\n    <rect x=\"4\" y=\"4\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"14\" y=\"4\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"14\" y=\"14\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"4\" y=\"14\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n  `;\r\n        return svg;\r\n    }\r\n    svgPause() {\r\n        return this.createSVG('w-5 h-5', 'M7 4h4v12H7V4zm6 0h4v12h-4V4z');\r\n    }\r\n    svgFullscreen() {\r\n        return this.createSVG('w-4 h-4', 'M4 8V4h4M4 16v4h4M20 8V4h-4M20 16v4h-4', true);\r\n    }\r\n    createSVG(size, d, stroke = false) {\r\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        svg.setAttribute('class', `${size} text-black-300`);\r\n        svg.setAttribute('viewBox', stroke ? '0 0 24 24' : '0 0 20 20');\r\n        if (stroke) {\r\n            svg.setAttribute('fill', 'none');\r\n            svg.setAttribute('stroke', 'currentColor');\r\n            svg.setAttribute('stroke-width', '2');\r\n            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n            path.setAttribute('stroke-linecap', 'round');\r\n            path.setAttribute('stroke-linejoin', 'round');\r\n            path.setAttribute('d', d);\r\n            svg.appendChild(path);\r\n        }\r\n        else if (d) {\r\n            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n            path.setAttribute('fill', 'currentColor');\r\n            path.setAttribute('d', d);\r\n            svg.appendChild(path);\r\n        }\r\n        return svg;\r\n    }\r\n    togglePlayUI(isPlaying) {\r\n        this.playButton.style.display = isPlaying ? 'none' : 'flex';\r\n        this.pauseButton.style.display = isPlaying ? 'flex' : 'none';\r\n    }\r\n    setMuteIcon(muted) {\r\n        this.muteIcon.innerHTML = muted\r\n            ? `<svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\">\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M18.364 5.636l-12.728 12.728\" />\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M9 9v6l5 4V5l-5 4z\" />\r\n         </svg>`\r\n            : `<svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\">\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n         </svg>`;\r\n    }\r\n    renderTags(container, tags, index, toggleTag) {\r\n        container.innerHTML = ''; // clear previous tags\r\n        const visible = 5;\r\n        const section = Math.floor(index / 2) + 1;\r\n        tags.forEach((tag, i) => {\r\n            const btn = document.createElement('button');\r\n            btn.className = `${tag}-id tag-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition \r\n  hover:bg-white/10 hover:border-gray-400 ${i >= visible ? 'hidden-tag hidden' : ''}`;\r\n            if (this.state.activeTags[section] && this.state.activeTags[section].includes(tag)) {\r\n                btn.classList.add('active-tag'); // mark button active\r\n            }\r\n            btn.textContent = tag;\r\n            btn.addEventListener('click', () => {\r\n                if (toggleTag) {\r\n                    toggleTag(btn);\r\n                }\r\n            });\r\n            container.appendChild(btn);\r\n        });\r\n        if (tags.length > visible) {\r\n            const toggleBtn = document.createElement('button');\r\n            toggleBtn.textContent = 'More';\r\n            toggleBtn.className = 'tag-toggle';\r\n            toggleBtn.onclick = () => {\r\n                container.querySelectorAll('.hidden-tag').forEach(el => el.classList.toggle('hidden'));\r\n            };\r\n            container.appendChild(toggleBtn);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://video-player/./src/HTML.ts?");

/***/ }),

/***/ "./src/Player.ts":
/*!***********************!*\
  !*** ./src/Player.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Players {\r\n    constructor(state, html) {\r\n        this.folder = './videos/';\r\n        this.muted = true;\r\n        this.playerCount = 8;\r\n        this.selectedTags = new Map();\r\n        this.cachedVideos = [];\r\n        this.state = state;\r\n        this.html = html;\r\n        // this.addFormsToPlayers();\r\n    }\r\n    async init() {\r\n        this.active = this.initializeActive(this.playerCount);\r\n        this.html.allTags = await this.fetchAllTags();\r\n        const toolbar = this.createToolbar();\r\n        const videoContainer = this.createVideoContainer();\r\n        document.body.appendChild(toolbar);\r\n        document.body.appendChild(videoContainer);\r\n        this.attachEventListeners();\r\n        this.initializeMuteButton();\r\n        await this.loadVideos();\r\n        // this.updateLayout();\r\n        // this.addFormsToPlayers();\r\n    }\r\n    async loadVideos(active = false, reload = false) {\r\n        for (let i = 0; i < this.html.videoPlayers.length; i++) {\r\n            if (!this.state.multiSection && i > 1) {\r\n                continue;\r\n            }\r\n            if (reload && !this.html.videoPlayers[i].src) {\r\n            }\r\n            else if (active && this.active && this.active[i] && this.html.videoPlayers[i].src) {\r\n                continue;\r\n            }\r\n            const section = Math.ceil((i + 1) / 2);\r\n            // get current position for that section\r\n            const pos = this.state.positions[section];\r\n            const playerIndex = i;\r\n            // assign video source based on position\r\n            console.log(\"assigning to player\", playerIndex, \"the video\", pos);\r\n            this.html.videoPlayers[playerIndex].src = this.folder + pos + '.mp4';\r\n            this.html.videoPlayers[playerIndex].preload = 'auto';\r\n            const res = await this.getVideoMetadata(pos);\r\n            this.populateMetadataForm(playerIndex, res);\r\n            await this.state.modifyPosition(section);\r\n        }\r\n    }\r\n    createToolbar() {\r\n        const toolbar = this.html.createDiv('button-toolbar');\r\n        toolbar.className = 'button-toolbar flex justify-center items-center gap-3 p-3 bg-gray-900';\r\n        // Buttons\r\n        this.html.playButton = this.html.createButton('playButton', this.html.svgPlay());\r\n        this.html.pauseButton = this.html.createButton('pauseButton', this.html.svgPause());\r\n        this.html.fullscreenButton = this.html.createButton('fullscreenButton', this.html.svgFullscreen());\r\n        this.html.resizeButton = this.html.createButton('resizeButton', this.html.svgGrid4());\r\n        this.html.muteIcon = this.html.createSpan('muteIcon');\r\n        this.html.muteToggle = this.html.createButton('muteToggle', this.html.muteIcon);\r\n        this.html.hideIcon = this.html.createSpan('hideIcon');\r\n        const iconBurger = `\r\n    <svg class=\"w-5 h-5 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\">\r\n      <line x1=\"3\" y1=\"6\" x2=\"21\" y2=\"6\" stroke-linecap=\"round\" />\r\n      <line x1=\"3\" y1=\"12\" x2=\"21\" y2=\"12\" stroke-linecap=\"round\" />\r\n      <line x1=\"3\" y1=\"18\" x2=\"21\" y2=\"18\" stroke-linecap=\"round\" />\r\n    </svg>\r\n  `;\r\n        this.html.hideIcon.innerHTML = iconBurger;\r\n        this.html.hideFormsButton = this.html.createButton('hideForms', this.html.hideIcon);\r\n        this.html.hideFormsButton.classList.add('hide-button');\r\n        this.html.hideFormsButton.addEventListener('click', () => {\r\n            const forms = document.querySelectorAll('.metadata-form');\r\n            forms.forEach(el => el.classList.toggle('hidden'));\r\n        });\r\n        // Search bar element\r\n        const searchInput = document.createElement('input');\r\n        searchInput.id = 'search-input';\r\n        searchInput.type = 'text';\r\n        searchInput.placeholder = 'Search videos...';\r\n        searchInput.className =\r\n            'w-1/3 p-2 rounded-lg text-black focus:outline-none focus:ring-2 focus:ring-pink-500';\r\n        searchInput.addEventListener('input', async (e) => {\r\n            const value = e.target.value.trim();\r\n            await this.fetchVideos(value)\r\n                .then((videos) => this.renderSearchResults(videos))\r\n                .catch(console.error);\r\n        });\r\n        // append everything inline\r\n        toolbar.append(this.html.hideFormsButton, this.html.playButton, this.html.pauseButton, searchInput, // â¬… add here between buttons\r\n        this.html.fullscreenButton, this.html.resizeButton, this.html.muteToggle);\r\n        return toolbar;\r\n    }\r\n    async renderSearchResults(videos) {\r\n        const container = document.getElementById('video-container');\r\n        if (!container)\r\n            return;\r\n        if (videos.length === 0) {\r\n            await this.init();\r\n            return;\r\n        }\r\n        container.innerHTML = `\r\n    <div class=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 w-full\">\r\n      ${videos\r\n            .map((v) => {\r\n            var _a;\r\n            const thumbPath = `./videos/thumbnails/${v.id}.jpg`;\r\n            return `\r\n            <div class=\"bg-gray-800 rounded-lg p-2 shadow hover:scale-105 transition-transform\">\r\n              <img src=\"${thumbPath}\" alt=\"${v.title}\" class=\"rounded-md mb-2 w-full\">\r\n              <h3 class=\"text-sm font-semibold truncate\">${v.title}</h3>\r\n              <p class=\"text-xs text-gray-400\">${((_a = v.models) === null || _a === void 0 ? void 0 : _a.map((m) => m.name).join(', ')) || ''}</p>\r\n            </div>\r\n          `;\r\n        })\r\n            .join('')}\r\n    </div>`;\r\n    }\r\n    updateLayout() {\r\n        const isMulti = this.state.multiSection;\r\n        // Always update players 0 and 1\r\n        [0, 1].forEach(index => {\r\n            const player = this.html.videoPlayers[index];\r\n            const wrapper = player.parentElement;\r\n            wrapper.classList.toggle('half-size', isMulti);\r\n        });\r\n        this.html.videoPlayers.forEach((player, index) => {\r\n            if (index < 2)\r\n                return;\r\n            const wrapper = player.parentElement;\r\n            if (!wrapper)\r\n                return;\r\n            // show even-indexed players in multi mode, hide odd ones\r\n            const shouldBeVisible = isMulti ? index % 2 === 0 : index < 2;\r\n            wrapper.classList.toggle('hidden', !shouldBeVisible);\r\n        });\r\n    }\r\n    initializeMuteButton() {\r\n        var _a;\r\n        const muteIcon = document.getElementById('muteIcon');\r\n        // set initial state: all players muted + muted icon\r\n        this.html.videoPlayers.forEach(player => {\r\n            player.muted = this.muted;\r\n        });\r\n        if (muteIcon) {\r\n            muteIcon.innerHTML = `\r\n      <svg class=\"w-4 h-4 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"\r\n        viewBox=\"0 0 24 24\">\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15 9a3 3 0 010 6\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M17.5 7.5a6 6 0 010 9\" />\r\n      </svg>`;\r\n        }\r\n        // add click listener\r\n        (_a = this.html.muteToggle) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => {\r\n            this.muted = !this.muted;\r\n            this.html.videoPlayers.forEach(player => {\r\n                player.muted = this.muted;\r\n            });\r\n            muteIcon.innerHTML = !this.muted\r\n                ? `\r\n      <!-- Muted icon: speaker only -->\r\n      <svg class=\"w-4 h-4 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"\r\n        viewBox=\"0 0 24 24\">\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n      </svg>`\r\n                : `\r\n      <!-- Unmuted icon: speaker with waves -->\r\n      <svg class=\"w-4 h-4 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"\r\n        viewBox=\"0 0 24 24\">\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15 9a3 3 0 010 6\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M17.5 7.5a6 6 0 010 9\" />\r\n      </svg>`;\r\n        });\r\n    }\r\n    attachEventListeners() {\r\n        this.html.playButton.addEventListener('click', async () => {\r\n            try {\r\n                for (let i = 0; i < this.html.videoPlayers.length; i++) {\r\n                    const player = this.html.videoPlayers[i];\r\n                    if (this.active && this.active[i]) {\r\n                        await player.play();\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                console.error('Error playing selected videos:', error);\r\n            }\r\n        });\r\n        this.html.pauseButton.addEventListener('click', async () => {\r\n            try {\r\n                // play only videos where the player is active in state\r\n                this.html.videoPlayers\r\n                    .forEach(player => player.pause());\r\n            }\r\n            catch (error) {\r\n                console.error('Error playing selected videos:', error);\r\n            }\r\n        });\r\n        this.html.videoPlayers.forEach((player, index) => {\r\n            player.addEventListener('ended', () => {\r\n                this.handlePlayerEnded(index);\r\n            });\r\n            player.addEventListener('click', () => this.togglePlayPause(index));\r\n        });\r\n        this.html.resizeButton.addEventListener('click', () => {\r\n            console.log(\"Resizing, status:\", this.state.multiSection);\r\n            this.state.multiSection = !this.state.multiSection;\r\n            console.log(\"Resizing, new status:\", this.state.multiSection);\r\n            // this.updateResizeIcon();\r\n            this.updateLayout();\r\n            this.loadVideos(true, true);\r\n        });\r\n        this.html.fullscreenButton.addEventListener('click', () => {\r\n            this.toggleFullscreen();\r\n        });\r\n    }\r\n    initializeActive(playerCount) {\r\n        const act = {};\r\n        for (let i = 0; i < playerCount; i++) {\r\n            act[i] = (i % 2 === 0);\r\n        }\r\n        console.log(act);\r\n        return act;\r\n    }\r\n    async getVideoMetadata(videoId) {\r\n        try {\r\n            const response = await fetch(`${this.state.apiUrl}/videos/${videoId}`);\r\n            if (!response.ok)\r\n                throw new Error(`Failed to fetch metadata for videoId ${videoId}`);\r\n            return await response.json();\r\n        }\r\n        catch (error) {\r\n            console.error(`Error fetching metadata for videoId ${videoId}:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    async handlePlayerEnded(playerIndex) {\r\n        console.log(`Player ${playerIndex} ended, switching video...`);\r\n        const section = Math.ceil((playerIndex + 1) / 2);\r\n        // flip 0â†”1, 2â†”3, 4â†”5, 6â†”7\r\n        const nextPlayerIndex = playerIndex % 2 === 0 ? playerIndex + 1 : playerIndex - 1;\r\n        const primary = this.html.videoPlayers[playerIndex];\r\n        const secondary = this.html.videoPlayers[nextPlayerIndex];\r\n        if (!primary || !secondary) {\r\n            console.error(`Invalid player index: ${playerIndex}`);\r\n            return;\r\n        }\r\n        await secondary.play();\r\n        console.log(\"section\", section);\r\n        this.state.modifyPosition(section);\r\n        try {\r\n            // hide/show wrappers instead of videos\r\n            const currentWrapper = primary.parentElement;\r\n            const nextWrapper = secondary.parentElement;\r\n            nextWrapper.classList.remove(\"hidden\");\r\n            currentWrapper.classList.add(\"hidden\");\r\n            // ensure active map exists, then toggle active states correctly (no +1 offset)\r\n            if (!this.active) {\r\n                this.active = this.initializeActive(this.playerCount);\r\n            }\r\n            this.active[nextPlayerIndex] = true;\r\n            this.active[playerIndex] = false;\r\n            console.log(this.state.positions[section], \"current position for section\", section);\r\n            const pos = this.state.positions[section];\r\n            const filename = `${this.folder}${pos}.mp4`;\r\n            primary.src = filename;\r\n            primary.preload = \"auto\";\r\n            const res = await this.getVideoMetadata(pos);\r\n            this.populateMetadataForm(playerIndex, res);\r\n            // primary.load();\r\n        }\r\n        catch (err) {\r\n            console.error(`Error in section ${section}, player ${playerIndex}:`, err);\r\n        }\r\n    }\r\n    togglePlayPause(index) {\r\n        const video = this.html.videoPlayers[index];\r\n        if (video.paused) {\r\n            video.play();\r\n            // this.active![index + 1] = true; // mark as active\r\n            // // hide form when playing\r\n            // const wrapper = video.parentElement;\r\n            // if (wrapper) {\r\n            //     const form = wrapper.querySelector('.form-container');\r\n            //     form?.classList.add('hidden');\r\n            // }\r\n        }\r\n        else {\r\n            video.pause();\r\n            // this.active![index + 1] = false; // mark as inactive\r\n            // // show form when paused\r\n            // const wrapper = video.parentElement;\r\n            // if (wrapper) {\r\n            //     const form = wrapper.querySelector('.form-container');\r\n            //     form?.classList.remove('hidden');\r\n            // }\r\n        }\r\n    }\r\n    // private async addFormsToPlayers() {\r\n    //     let tags: { id: number; title: string }[] = [];\r\n    //     try {\r\n    //         const response = await fetch('http://:3000/tags');\r\n    //         if (!response.ok) throw new Error('Failed to fetch tags');\r\n    //         const bodyText = await new Response(response.body).text();\r\n    //         console.log(JSON.parse(bodyText));\r\n    //         tags = JSON.parse(bodyText);\r\n    //     } catch (error) {\r\n    //         console.error('Error loading tags:', error);\r\n    //     }\r\n    //     for (let i = 1; i <= 8; i++) {\r\n    //         const wrapper = document.getElementById(`player${i}`);\r\n    //         if (!wrapper) continue;\r\n    //         const optionsHtml = tags.length\r\n    //             ? tags.map(tag => `<option value=\"${tag.title}\">${tag.title}</option>`).join('')\r\n    //             : `...`;\r\n    //         console.log(tags);\r\n    //         const formContainer = document.createElement('div');\r\n    //         formContainer.className = 'form-container hidden'; // initially hidden\r\n    //         formContainer.innerHTML = `\r\n    //         <form id=\"videoForm${i}\">\r\n    //             <select id=\"tagSelect${i}\" multiple style=\"width: 100%;\">\r\n    //                 ${optionsHtml}\r\n    //             </select>\r\n    //             <input type=\"text\" id=\"videoTitle${i}\" placeholder=\"Video Title\" style=\"width: 100%; margin-top: 5px;\" />\r\n    //             <input type=\"text\" id=\"videoModel${i}\" placeholder=\"Model\" style=\"width: 100%; margin-top: 5px;\" />\r\n    //             <button type=\"submit\" class=\"submit-button\" style=\"margin-top: 5px;\">Submit</button>\r\n    //         </form>\r\n    //     `;\r\n    //         wrapper.appendChild(formContainer);\r\n    //         const form = formContainer.querySelector('form');\r\n    //         form?.addEventListener('submit', async (event) => {\r\n    //             event.preventDefault();\r\n    //             const titleInput = form.querySelector(`#videoTitle${i}`) as HTMLInputElement;\r\n    //             const tagSelect = form.querySelector(`#tagSelect${i}`) as HTMLSelectElement;\r\n    //             const title = titleInput?.value || '';\r\n    //             const tags = Array.from(tagSelect?.selectedOptions || []).map(opt => opt.value);\r\n    //             const video = document.getElementById(`videoPlayer${i}`) as HTMLVideoElement | null;\r\n    //             let videoName = '';\r\n    //             if (video && video.src) {\r\n    //                 videoName = video.src.split('/').pop()?.replace(/\\.mp4$/, '') || '';\r\n    //             }\r\n    //             const data = {\r\n    //                 title,\r\n    //                 tags,\r\n    //                 id: videoName,\r\n    //             };\r\n    //             try {\r\n    //                 const response = await fetch(`${this.state.apiUrl}/videos`, {\r\n    //                     method: 'POST',\r\n    //                     headers: { 'Content-Type': 'application/json' },\r\n    //                     body: JSON.stringify(data),\r\n    //                 });\r\n    //                 if (!response.ok) {\r\n    //                     throw new Error(`Server responded with status ${response.status}`);\r\n    //                 }\r\n    //                 console.log(`Data from player ${i} submitted successfully:`, data);\r\n    //             } catch (error) {\r\n    //                 console.error(`Error submitting data for player ${i}:`, error);\r\n    //             }\r\n    //         });\r\n    //     }\r\n    // }\r\n    async toggleFullscreen() {\r\n        const doc = document;\r\n        const el = document.documentElement;\r\n        if (!doc.fullscreenElement) {\r\n            await el.requestFullscreen();\r\n        }\r\n        else {\r\n            await doc.exitFullscreen();\r\n        }\r\n    }\r\n    populateMetadataForm(index, data) {\r\n        if (!this.isMetadataValid(data) || !data) {\r\n            console.warn(`Invalid or empty metadata for Player ${index}`);\r\n            return;\r\n        }\r\n        const form = document.getElementById(`metaForm${index + 1}`);\r\n        if (!form)\r\n            return;\r\n        const inputs = form.querySelectorAll('input');\r\n        inputs.forEach((input) => {\r\n            switch (input.placeholder) {\r\n                case 'Title':\r\n                    input.value = data.title || '';\r\n                    break;\r\n                case 'Models':\r\n                    input.value = Array.isArray(data.models) ? data.models.join(', ') : (data.models || '');\r\n                    break;\r\n                case 'Studio':\r\n                    input.value = data.studio || '';\r\n                    break;\r\n            }\r\n        });\r\n        if (!data.tags || data.tags.length === 0) {\r\n            return;\r\n        }\r\n        const tagsWrapper = this.html.tagsWrappers[index];\r\n        if (!tagsWrapper)\r\n            return;\r\n        // render toggleable tags directly here\r\n        this.html.renderTags(tagsWrapper, data.tags.map(t => t.title), index, this.toggleTag.bind(this));\r\n    }\r\n    async toggleTag(btn) {\r\n        var _a;\r\n        const tag = (_a = btn.textContent) === null || _a === void 0 ? void 0 : _a.trim();\r\n        if (!tag)\r\n            return;\r\n        const tagClass = `${tag}-id`;\r\n        const sectionEl = btn.closest('[id^=\"player\"]');\r\n        if (!sectionEl)\r\n            throw new Error(`Section element not found for tag \"${tag}\"`);\r\n        // toggle active-tag class for all matching elements in the same section\r\n        const isActive = btn.classList.toggle('active-tag');\r\n        sectionEl.querySelectorAll(`.${tagClass}`).forEach(el => {\r\n            if (el !== btn)\r\n                el.classList.toggle('active-tag', isActive);\r\n        });\r\n        // extract player number (e.g. player3 â†’ 3)\r\n        const playerId = sectionEl.id.match(/\\d+/);\r\n        if (!playerId)\r\n            return;\r\n        const playerNumber = parseInt(playerId[0], 10);\r\n        const section = Math.floor(playerNumber / 2 + 1);\r\n        const tags = this.state.activeTags[section];\r\n        // sync tag state\r\n        if (isActive) {\r\n            if (!tags.includes(tag))\r\n                tags.push(tag);\r\n        }\r\n        else {\r\n            this.state.activeTags[section] = tags.filter(t => t !== tag);\r\n        }\r\n        await this.loadVideos(true);\r\n    }\r\n    async fetchAllTags() {\r\n        try {\r\n            const response = await fetch(`${this.state.apiUrl}/tags`, {\r\n                method: 'GET',\r\n                headers: { 'Content-Type': 'application/json' },\r\n            });\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            const tags = await response.json();\r\n            return tags; // array of tag objects\r\n        }\r\n        catch (error) {\r\n            console.error('Failed to fetch tags:', error);\r\n            return [];\r\n        }\r\n    }\r\n    isMetadataValid(data) {\r\n        var _a, _b;\r\n        if (!data)\r\n            return false;\r\n        const hasTitle = !!((_a = data.title) === null || _a === void 0 ? void 0 : _a.trim());\r\n        const hasModels = Array.isArray(data.models) && data.models.length > 0;\r\n        const hasStudio = !!((_b = data.studio) === null || _b === void 0 ? void 0 : _b.trim());\r\n        const hasTags = Array.isArray(data.tags) && data.tags.length > 0;\r\n        return hasTitle || hasModels || hasStudio || hasTags;\r\n    }\r\n    async fetchVideos(query) {\r\n        // if query empty and cache exists, use it\r\n        if (!query && this.cachedVideos.length)\r\n            return this.cachedVideos;\r\n        const url = query ? `${this.state.apiUrl}/videos?search=${encodeURIComponent(query)}` : `${this.state.apiUrl}/videos`;\r\n        const res = await fetch(url);\r\n        if (!res.ok)\r\n            throw new Error('Failed to fetch videos');\r\n        const data = await res.json();\r\n        if (!query)\r\n            this.cachedVideos = data; // cache all videos\r\n        return data;\r\n    }\r\n    createMetadataForm(index) {\r\n        const form = this.html.createDiv(`metaForm${index}`, 'metadata-form p-2');\r\n        const makeInput = (placeholder, key) => {\r\n            const input = document.createElement('input');\r\n            input.type = 'text';\r\n            input.placeholder = placeholder;\r\n            input.className = 'block w-full mb-2 bg-transparent text-black border border-gray-400 px-2 py-1 rounded placeholder-black-400';\r\n            input.addEventListener('input', async (event) => {\r\n                event.preventDefault();\r\n                await this.updateMeta(index, key, input.value);\r\n            });\r\n            return input;\r\n        };\r\n        const titleInput = makeInput('Title', 'title');\r\n        const modelInput = makeInput('Models', 'models'); // or 'model' if that is your key\r\n        const studioInput = makeInput('Studio', 'studio');\r\n        const tagsWrapper = this.html.createDiv(`tags${index}`, 'tag-container');\r\n        // in your constructor or before usage\r\n        this.html.tagsWrappers.push(tagsWrapper);\r\n        // + Button to show available tags\r\n        const addTagBtn = document.createElement('button');\r\n        addTagBtn.type = 'button';\r\n        addTagBtn.textContent = '+';\r\n        addTagBtn.className = 'plus-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition hover:bg-white/10 hover:border-gray-400';\r\n        const tagListDropdown = document.createElement('div');\r\n        tagListDropdown.className = 'tag-list mt-2 hidden bg-white text-black border border-gray-300 rounded shadow-md z-10 absolute';\r\n        tagListDropdown.style.minWidth = '10rem';\r\n        this.html.allTags.forEach((tag) => {\r\n            const tagItem = document.createElement('div');\r\n            tagItem.textContent = tag.title;\r\n            tagItem.className = 'px-3 py-2 hover:bg-gray-200 cursor-pointer';\r\n            tagItem.addEventListener('click', async () => {\r\n                const video = await this.updateMeta(index, 'tag', tag.title, tag.id);\r\n                tagListDropdown.classList.add('hidden'); // hide dropdown\r\n                this.populateMetadataForm((index), video);\r\n            });\r\n            tagListDropdown.appendChild(tagItem);\r\n        });\r\n        // Toggle tag dropdown visibility\r\n        addTagBtn.addEventListener('click', () => {\r\n            tagListDropdown.classList.toggle('hidden');\r\n        });\r\n        // UPLOAD button + form\r\n        const uploadBtn = document.createElement('button');\r\n        uploadBtn.type = 'button';\r\n        uploadBtn.innerHTML = 'ðŸ“¤'; // could be replaced with an icon <svg> if you want\r\n        uploadBtn.className = 'upload-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition hover:bg-white/10 hover:border-gray-400';\r\n        const uploadFormWrapper = document.createElement('div');\r\n        uploadFormWrapper.className = 'upload-form hidden mt-2 bg-white text-black border border-gray-300 rounded shadow-md p-2 z-10 absolute';\r\n        uploadFormWrapper.style.minWidth = '14rem';\r\n        // form fields inside upload form\r\n        const fileInput = document.createElement('input');\r\n        fileInput.type = 'file';\r\n        fileInput.multiple = true;\r\n        fileInput.className = 'block w-full mb-2';\r\n        const uploadTitleInput = document.createElement('input');\r\n        uploadTitleInput.type = 'text';\r\n        uploadTitleInput.placeholder = 'Title';\r\n        uploadTitleInput.className = 'block w-full mb-2 border border-gray-400 px-2 py-1 rounded';\r\n        // tag select for uploaded video\r\n        const uploadTagSelect = document.createElement('select');\r\n        uploadTagSelect.className = 'block w-full mb-2 border border-gray-400 px-2 py-1 rounded';\r\n        this.html.allTags.forEach((tag) => {\r\n            const opt = document.createElement('option');\r\n            opt.value = tag.id.toString();\r\n            opt.textContent = tag.title;\r\n            uploadTagSelect.appendChild(opt);\r\n        });\r\n        const submitUploadBtn = document.createElement('button');\r\n        submitUploadBtn.type = 'button';\r\n        submitUploadBtn.textContent = 'Upload';\r\n        submitUploadBtn.className = 'px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700';\r\n        submitUploadBtn.addEventListener('click', async () => {\r\n            var _a;\r\n            if (!((_a = fileInput.files) === null || _a === void 0 ? void 0 : _a.length))\r\n                return alert('Please select a file.');\r\n            const formData = new FormData();\r\n            // append all selected files\r\n            Array.from(fileInput.files).forEach((file) => {\r\n                formData.append('files', file);\r\n            });\r\n            formData.append('title', uploadTitleInput.value);\r\n            formData.append('tagId', uploadTagSelect.value);\r\n            const res = await fetch(`${this.state.apiUrl}/upload-video`, {\r\n                method: 'POST',\r\n                body: formData,\r\n            });\r\n            if (res.ok) {\r\n                alert('Upload successful');\r\n                uploadFormWrapper.classList.add('hidden');\r\n            }\r\n            else {\r\n                alert('Upload failed');\r\n            }\r\n        });\r\n        uploadFormWrapper.append(fileInput, uploadTitleInput, uploadTagSelect, submitUploadBtn);\r\n        uploadBtn.addEventListener('click', () => {\r\n            uploadFormWrapper.classList.toggle('hidden');\r\n        });\r\n        form.append(titleInput, modelInput, studioInput, tagsWrapper, addTagBtn, tagListDropdown, uploadBtn, uploadFormWrapper);\r\n        return form;\r\n    }\r\n    async updateMeta(index, key, value, tagId) {\r\n        // gather data to send, assuming you have videos in an array like this:\r\n        const video = this.html.videoPlayers[index];\r\n        if (!video) {\r\n            console.error(`Video player for index ${index} not found`);\r\n            return null;\r\n        }\r\n        const src = video.src;\r\n        if (!src) {\r\n            console.error(`Video source for player at index ${index} is missing`);\r\n            return null;\r\n        }\r\n        const filename = src.split('/').pop();\r\n        if (!filename) {\r\n            console.error(`Could not extract filename from src for video at index ${index}`);\r\n            return null;\r\n        }\r\n        const videoId = filename.replace('.mp4', '');\r\n        if (!videoId) {\r\n            console.error(`Extracted video ID is empty for video at index ${index}`);\r\n            return null;\r\n        }\r\n        const body = { id: videoId };\r\n        // build request body dynamically\r\n        if (key === 'title') {\r\n            body.title = value;\r\n        }\r\n        else if (key === 'models') {\r\n            body.models = value;\r\n        }\r\n        else if (key === 'studio') {\r\n            body.studio = value;\r\n        }\r\n        else if (key === 'tag') {\r\n            body.tag = { id: tagId, title: value };\r\n        }\r\n        try {\r\n            const response = await fetch(`${this.state.apiUrl}/videos`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify(body),\r\n            });\r\n            if (!response.ok) {\r\n                console.error(`HTTP error! status: ${response.status}`);\r\n                return null;\r\n            }\r\n            // After updating, fetch the latest metadata for this video and return it\r\n            const updated = await this.getVideoMetadata(Number(videoId));\r\n            return updated;\r\n        }\r\n        catch (error) {\r\n            console.error(`Failed to update metadata for video ${index}:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    createVideoContainer() {\r\n        const container = this.html.createDiv('video-container');\r\n        this.html.videoPlayers = [];\r\n        for (let i = 0; i <= 7; i++) {\r\n            const wrapper = this.html.createDiv(`player${i}`, `${this.html.getPositionClass(i)}`);\r\n            const form = this.createMetadataForm(i);\r\n            wrapper.appendChild(form);\r\n            const video = document.createElement('video');\r\n            video.id = `videoPlayer${i}`;\r\n            video.className = 'video-layer';\r\n            video.playsInline = true;\r\n            video.setAttribute('webkit-playsinline', '');\r\n            video.muted = true;\r\n            video.autoplay = true;\r\n            wrapper.appendChild(video);\r\n            container.appendChild(wrapper);\r\n            this.html.videoPlayers.push(video);\r\n        }\r\n        return container;\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Players);\r\n\n\n//# sourceURL=webpack://video-player/./src/Player.ts?");

/***/ }),

/***/ "./src/State.ts":
/*!**********************!*\
  !*** ./src/State.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass State {\r\n    constructor() {\r\n        this.multiSection = false; // Whether to use multiple sections\r\n        this.randomized = true;\r\n        this.percentChance = 25; // 25% chance to modify position\r\n        this.endIndex = 3194; // Maximum position index\r\n        this.positions = {\r\n            1: this.randomized ? this.randomInRange(1, this.endIndex * 0.25) : 1,\r\n            2: this.randomized ? this.randomInRange(this.endIndex * 0.25, this.endIndex * 0.5) : 500,\r\n            3: this.randomized ? this.randomInRange(this.endIndex * 0.5, this.endIndex * 0.75) : 1000,\r\n            4: this.randomized ? this.randomInRange(this.endIndex * 0.75, this.endIndex) : 1500\r\n        };\r\n        this.activeTags = {\r\n            1: [\"\"],\r\n            2: [\"\"],\r\n            3: [\"\"],\r\n            4: [\"\"]\r\n        };\r\n        this.apiUrl = \"http://localhost:3000\";\r\n    }\r\n    async modifyPosition(section) {\r\n        var _a;\r\n        if (!(section in this.positions)) {\r\n            throw new Error(`Invalid section: ${section}`);\r\n        }\r\n        // \r\n        const taggedVideos = (_a = (await this.fetchVideosByTags(section))) !== null && _a !== void 0 ? _a : [];\r\n        // Tagged mode\r\n        if (taggedVideos.length > 0) {\r\n            const currentId = this.positions[section];\r\n            const videoIds = taggedVideos.map(v => v.id);\r\n            // Random within tagged\r\n            if (this.randomized) {\r\n                const roll = Math.random() * 100;\r\n                if (roll < this.percentChance) {\r\n                    // pick random from taggedVideos\r\n                    const randomVideo = taggedVideos[Math.floor(Math.random() * taggedVideos.length)];\r\n                    this.positions[section] = randomVideo.id;\r\n                    return;\r\n                }\r\n            }\r\n            let currentIndex = videoIds.indexOf(currentId);\r\n            if (currentIndex === -1) {\r\n                // Video is last in tagged list or not found, reset to first tagged video\r\n                this.positions[section] = videoIds[0];\r\n                return;\r\n            }\r\n            this.positions[section] = videoIds[currentIndex + 1];\r\n            return;\r\n        }\r\n        // Untagged mode\r\n        if (this.randomized) {\r\n            const roll = Math.random() * 100;\r\n            if (roll < this.percentChance) {\r\n                const newIndex = Math.floor(Math.random() * this.endIndex) + 1;\r\n                this.positions[section] = newIndex;\r\n                return;\r\n            }\r\n        }\r\n        const nextValue = this.positions[section] + 1 > this.endIndex ? 1 : this.positions[section] + 1;\r\n        // Default increment\r\n        this.positions[section] = nextValue;\r\n    }\r\n    async fetchVideosByTags(section) {\r\n        const tags = this.activeTags[section];\r\n        if (!tags || tags.length === 0)\r\n            return null;\r\n        try {\r\n            const response = await fetch(`${this.apiUrl}/videos/by-tags`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({ tags }),\r\n            });\r\n            if (!response.ok)\r\n                throw new Error(`Server error (${response.status})`);\r\n            const videos = await response.json();\r\n            return videos;\r\n        }\r\n        catch (err) {\r\n            console.error(`Failed to fetch videos for section ${section} with tags ${tags}`, err);\r\n            return null;\r\n        }\r\n    }\r\n    randomInRange(min, max) {\r\n        const minInt = Math.floor(min);\r\n        const maxInt = Math.floor(max);\r\n        return Math.floor(Math.random() * (maxInt - minInt + 1)) + minInt;\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (State);\r\n\n\n//# sourceURL=webpack://video-player/./src/State.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State */ \"./src/State.ts\");\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Player */ \"./src/Player.ts\");\n/* harmony import */ var _HTML__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HTML */ \"./src/HTML.ts\");\n\r\n\r\n\r\ndocument.addEventListener('DOMContentLoaded', async (e) => {\r\n    e.preventDefault();\r\n    const state = new _State__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const html = new _HTML__WEBPACK_IMPORTED_MODULE_2__[\"default\"](state);\r\n    const players = new _Player__WEBPACK_IMPORTED_MODULE_1__[\"default\"](state, html);\r\n    await players.init();\r\n    // expose for debugging or external access\r\n    window.html = html;\r\n    window.state = state;\r\n    window.players = players;\r\n});\r\n\n\n//# sourceURL=webpack://video-player/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;