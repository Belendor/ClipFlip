/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/HTML.ts":
/*!*********************!*\
  !*** ./src/HTML.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HTML)\n/* harmony export */ });\nclass HTML {\r\n    constructor(state) {\r\n        // metadata\r\n        this.allTags = [];\r\n        // video players\r\n        this.videoPlayers = [];\r\n        // menu\r\n        this.tagsWrappers = [];\r\n        this.state = state;\r\n    }\r\n    createToolbar() {\r\n        const toolbar = this.createDiv('button-toolbar');\r\n        toolbar.className = 'button-toolbar';\r\n        // Buttons\r\n        this.playButton = this.createButton('playButton', this.svgPlay());\r\n        this.pauseButton = this.createButton('pauseButton', this.svgPause());\r\n        this.fullscreenButton = this.createButton('fullscreenButton', this.svgFullscreen());\r\n        // this.resizeIcon = this.createSpan('resizeIcon')\r\n        this.resizeButton = this.createButton('resizeButton', this.svgGrid4());\r\n        this.muteIcon = this.createSpan('muteIcon');\r\n        this.muteToggle = this.createButton('muteToggle', this.muteIcon);\r\n        this.hideIcon = this.createSpan('hideIcon');\r\n        const iconDown = `\r\n  <svg class=\"w-5 h-5 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\">\r\n    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19 9l-7 7-7-7\" />\r\n  </svg>`;\r\n        const iconBurger = `\r\n  <svg class=\"w-5 h-5 text-black-500\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\r\n    <line x1=\"3\" y1=\"6\" x2=\"21\" y2=\"6\" stroke-linecap=\"round\" />\r\n    <line x1=\"3\" y1=\"12\" x2=\"21\" y2=\"12\" stroke-linecap=\"round\" />\r\n    <line x1=\"3\" y1=\"18\" x2=\"21\" y2=\"18\" stroke-linecap=\"round\" />\r\n  </svg>\r\n`;\r\n        this.hideIcon.innerHTML = iconBurger;\r\n        this.hideIcon.innerHTML = iconBurger;\r\n        this.hideFormsButton = this.createButton('hideForms', this.hideIcon);\r\n        this.hideFormsButton.classList.add('hide-button');\r\n        this.hideFormsButton.addEventListener('click', () => {\r\n            const forms = document.querySelectorAll('.metadata-form');\r\n            forms.forEach(el => {\r\n                el.classList.toggle('hidden');\r\n            });\r\n            this.hideIcon.innerHTML = forms[0].classList.contains('hidden') ? iconBurger : iconBurger;\r\n        });\r\n        toolbar.append(this.hideFormsButton, this.playButton, this.pauseButton, this.fullscreenButton, this.resizeButton, this.muteToggle);\r\n        return toolbar;\r\n    }\r\n    createVideoContainer() {\r\n        const container = this.createDiv('video-container');\r\n        for (let i = 1; i <= 8; i++) {\r\n            const wrapper = this.createDiv(`player${i}`, `${this.getPositionClass(i)}`);\r\n            const form = this.createMetadataForm(i);\r\n            wrapper.appendChild(form);\r\n            const video = document.createElement('video');\r\n            video.id = `videoPlayer${i}`;\r\n            video.className = 'video-layer';\r\n            video.playsInline = true;\r\n            video.setAttribute('webkit-playsinline', '');\r\n            video.muted = true;\r\n            video.autoplay = true;\r\n            wrapper.appendChild(video);\r\n            container.appendChild(wrapper);\r\n            this.videoPlayers.push(video);\r\n        }\r\n        return container;\r\n    }\r\n    createButton(id, content) {\r\n        const btn = document.createElement('button');\r\n        btn.id = id;\r\n        btn.className =\r\n            'w-8 h-8 rounded border-2 bg-transparent flex items-center justify-center hover:bg-black/10 transition';\r\n        btn.style.borderColor = 'rgba(0, 0, 0, 0.4)';\r\n        btn.appendChild(content);\r\n        return btn;\r\n    }\r\n    createSpan(id) {\r\n        const span = document.createElement('span');\r\n        span.id = id;\r\n        span.className = 'text-black-300';\r\n        return span;\r\n    }\r\n    createDiv(id, className = '') {\r\n        const div = document.createElement('div');\r\n        div.id = id;\r\n        div.className = className;\r\n        return div;\r\n    }\r\n    getPositionClass(i) {\r\n        switch (i) {\r\n            case 1:\r\n            case 2:\r\n                return i === 2 ? 'video-layer hidden' : 'video-layer';\r\n            case 3:\r\n            case 4:\r\n                return 'video-layer-right half-size hidden';\r\n            case 5:\r\n            case 6:\r\n                return 'video-layer-botttom half-size hidden';\r\n            case 7:\r\n            case 8:\r\n                return 'video-layer-botttom-right half-size hidden';\r\n            default:\r\n                return 'video-layer hidden';\r\n        }\r\n    }\r\n    svgPlay() {\r\n        return this.createSVG('w-5 h-5', 'M6 4l10 6-10 6V4z');\r\n    }\r\n    svgGrid4() {\r\n        const svg = this.createSVG('w-5 h-5');\r\n        svg.setAttribute('viewBox', '0 0 24 24');\r\n        svg.innerHTML = `\r\n    <rect x=\"4\" y=\"4\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"14\" y=\"4\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"14\" y=\"14\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n    <rect x=\"4\" y=\"14\" width=\"6\" height=\"6\" stroke=\"currentColor\" stroke-width=\"2\" fill=\"none\" />\r\n  `;\r\n        return svg;\r\n    }\r\n    svgPause() {\r\n        return this.createSVG('w-5 h-5', 'M7 4h4v12H7V4zm6 0h4v12h-4V4z');\r\n    }\r\n    svgFullscreen() {\r\n        return this.createSVG('w-4 h-4', 'M4 8V4h4M4 16v4h4M20 8V4h-4M20 16v4h-4', true);\r\n    }\r\n    createSVG(size, d, stroke = false) {\r\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        svg.setAttribute('class', `${size} text-black-300`);\r\n        svg.setAttribute('viewBox', stroke ? '0 0 24 24' : '0 0 20 20');\r\n        if (stroke) {\r\n            svg.setAttribute('fill', 'none');\r\n            svg.setAttribute('stroke', 'currentColor');\r\n            svg.setAttribute('stroke-width', '2');\r\n            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n            path.setAttribute('stroke-linecap', 'round');\r\n            path.setAttribute('stroke-linejoin', 'round');\r\n            path.setAttribute('d', d);\r\n            svg.appendChild(path);\r\n        }\r\n        else if (d) {\r\n            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n            path.setAttribute('fill', 'currentColor');\r\n            path.setAttribute('d', d);\r\n            svg.appendChild(path);\r\n        }\r\n        return svg;\r\n    }\r\n    togglePlayUI(isPlaying) {\r\n        this.playButton.style.display = isPlaying ? 'none' : 'flex';\r\n        this.pauseButton.style.display = isPlaying ? 'flex' : 'none';\r\n    }\r\n    setMuteIcon(muted) {\r\n        this.muteIcon.innerHTML = muted\r\n            ? `<svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\">\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M18.364 5.636l-12.728 12.728\" />\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M9 9v6l5 4V5l-5 4z\" />\r\n         </svg>`\r\n            : `<svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" viewBox=\"0 0 24 24\">\r\n           <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n         </svg>`;\r\n    }\r\n    createMetadataForm(index) {\r\n        const form = this.createDiv(`metaForm${index}`, 'metadata-form p-2');\r\n        const makeInput = (placeholder, key) => {\r\n            const input = document.createElement('input');\r\n            input.type = 'text';\r\n            input.placeholder = placeholder;\r\n            input.className = 'block w-full mb-2 bg-transparent text-black border border-gray-400 px-2 py-1 rounded placeholder-black-400';\r\n            input.addEventListener('input', (event) => {\r\n                event.preventDefault();\r\n                this.updateMeta(index, key, input.value);\r\n            });\r\n            return input;\r\n        };\r\n        const titleInput = makeInput('Title', 'title');\r\n        const modelInput = makeInput('Models', 'models'); // or 'model' if that is your key\r\n        const studioInput = makeInput('Studio', 'studio');\r\n        const tagsWrapper = this.createDiv(`tags${index}`, 'tag-container');\r\n        // in your constructor or before usage\r\n        this.tagsWrappers.push(tagsWrapper);\r\n        // + Button to show available tags\r\n        const addTagBtn = document.createElement('button');\r\n        addTagBtn.type = 'button';\r\n        addTagBtn.textContent = '+';\r\n        addTagBtn.className = 'plus-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition hover:bg-white/10 hover:border-gray-400';\r\n        const tagListDropdown = document.createElement('div');\r\n        tagListDropdown.className = 'tag-list mt-2 hidden bg-white text-black border border-gray-300 rounded shadow-md z-10 absolute';\r\n        tagListDropdown.style.minWidth = '10rem';\r\n        this.allTags.forEach((tag) => {\r\n            const tagItem = document.createElement('div');\r\n            tagItem.textContent = tag.title;\r\n            tagItem.className = 'px-3 py-2 hover:bg-gray-200 cursor-pointer';\r\n            tagItem.addEventListener('click', () => {\r\n                this.updateMeta(index, 'tag', tag.title, tag.id);\r\n                tagListDropdown.classList.add('hidden'); // hide dropdown\r\n            });\r\n            tagListDropdown.appendChild(tagItem);\r\n        });\r\n        // Toggle tag dropdown visibility\r\n        addTagBtn.addEventListener('click', () => {\r\n            tagListDropdown.classList.toggle('hidden');\r\n        });\r\n        // UPLOAD button + form\r\n        const uploadBtn = document.createElement('button');\r\n        uploadBtn.type = 'button';\r\n        uploadBtn.innerHTML = 'ðŸ“¤'; // could be replaced with an icon <svg> if you want\r\n        uploadBtn.className = 'upload-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition hover:bg-white/10 hover:border-gray-400';\r\n        const uploadFormWrapper = document.createElement('div');\r\n        uploadFormWrapper.className = 'upload-form hidden mt-2 bg-white text-black border border-gray-300 rounded shadow-md p-2 z-10 absolute';\r\n        uploadFormWrapper.style.minWidth = '14rem';\r\n        // form fields inside upload form\r\n        const fileInput = document.createElement('input');\r\n        fileInput.type = 'file';\r\n        fileInput.multiple = true;\r\n        fileInput.className = 'block w-full mb-2';\r\n        const uploadTitleInput = document.createElement('input');\r\n        uploadTitleInput.type = 'text';\r\n        uploadTitleInput.placeholder = 'Title';\r\n        uploadTitleInput.className = 'block w-full mb-2 border border-gray-400 px-2 py-1 rounded';\r\n        // tag select for uploaded video\r\n        const uploadTagSelect = document.createElement('select');\r\n        uploadTagSelect.className = 'block w-full mb-2 border border-gray-400 px-2 py-1 rounded';\r\n        this.allTags.forEach((tag) => {\r\n            const opt = document.createElement('option');\r\n            opt.value = tag.id.toString();\r\n            opt.textContent = tag.title;\r\n            uploadTagSelect.appendChild(opt);\r\n        });\r\n        const submitUploadBtn = document.createElement('button');\r\n        submitUploadBtn.type = 'button';\r\n        submitUploadBtn.textContent = 'Upload';\r\n        submitUploadBtn.className = 'px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700';\r\n        submitUploadBtn.addEventListener('click', async () => {\r\n            var _a;\r\n            if (!((_a = fileInput.files) === null || _a === void 0 ? void 0 : _a.length))\r\n                return alert('Please select a file.');\r\n            const formData = new FormData();\r\n            // append all selected files\r\n            Array.from(fileInput.files).forEach((file) => {\r\n                formData.append('files', file);\r\n            });\r\n            formData.append('title', uploadTitleInput.value);\r\n            formData.append('tagId', uploadTagSelect.value);\r\n            const res = await fetch('https://www.clipflip.online/api/upload-video', {\r\n                method: 'POST',\r\n                body: formData,\r\n            });\r\n            if (res.ok) {\r\n                alert('Upload successful');\r\n                uploadFormWrapper.classList.add('hidden');\r\n            }\r\n            else {\r\n                alert('Upload failed');\r\n            }\r\n        });\r\n        uploadFormWrapper.append(fileInput, uploadTitleInput, uploadTagSelect, submitUploadBtn);\r\n        uploadBtn.addEventListener('click', () => {\r\n            uploadFormWrapper.classList.toggle('hidden');\r\n        });\r\n        form.append(titleInput, modelInput, studioInput, tagsWrapper, addTagBtn, tagListDropdown, uploadBtn, uploadFormWrapper);\r\n        return form;\r\n    }\r\n    async updateMeta(index, key, value, tagId) {\r\n        // gather data to send, assuming you have videos in an array like this:\r\n        const video = this.videoPlayers[index - 1];\r\n        if (!video) {\r\n            throw new Error(`Video player for index ${index} not found`);\r\n        }\r\n        const src = video.src;\r\n        if (!src) {\r\n            throw new Error(`Video source for player at index ${index} is missing`);\r\n        }\r\n        const filename = src.split('/').pop();\r\n        if (!filename) {\r\n            throw new Error(`Could not extract filename from src for video at index ${index}`);\r\n        }\r\n        const videoId = filename.replace('.mp4', '');\r\n        if (!videoId) {\r\n            throw new Error(`Extracted video ID is empty for video at index ${index}`);\r\n        }\r\n        console.log(videoId);\r\n        const body = { id: videoId };\r\n        // build request body dynamically\r\n        if (key === 'title') {\r\n            body.title = value;\r\n        }\r\n        else if (key === 'models') {\r\n            body.models = value;\r\n        }\r\n        else if (key === 'studio') {\r\n            body.studio = value;\r\n        }\r\n        else if (key === 'tag') {\r\n            body.tag = { id: tagId, title: value };\r\n        }\r\n        try {\r\n            const response = await fetch('https://www.clipflip.online/api/videos', {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify(body),\r\n            });\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error(`Failed to update metadata for video ${index}:`, error);\r\n            throw error; // rethrow to handle it upstream if needed\r\n        }\r\n    }\r\n    renderTags(container, tags, index, toggleTag) {\r\n        console.log(container.id, 'container class');\r\n        container.innerHTML = ''; // clear previous tags\r\n        const visible = 5;\r\n        const section = Math.floor(index / 2) + 1;\r\n        tags.forEach((tag, i) => {\r\n            const btn = document.createElement('button');\r\n            btn.className = `${tag}-id tag-button px-2 py-1 m-1 text-sm rounded border border-transparent text-gray-300 transition \r\n  hover:bg-white/10 hover:border-gray-400 ${i >= visible ? 'hidden-tag hidden' : ''}`;\r\n            // check if tag is already active for this section (index)\r\n            console.log(this.state.activeTags[section], tag, 'active check');\r\n            if (this.state.activeTags[section] && this.state.activeTags[section].includes(tag)) {\r\n                console.log(this.state.activeTags[section], tag, 'active');\r\n                btn.classList.add('active-tag'); // mark button active\r\n            }\r\n            btn.textContent = tag;\r\n            btn.addEventListener('click', () => {\r\n                if (toggleTag) {\r\n                    toggleTag(btn);\r\n                }\r\n            });\r\n            container.appendChild(btn);\r\n        });\r\n        if (tags.length > visible) {\r\n            const toggleBtn = document.createElement('button');\r\n            toggleBtn.textContent = 'More';\r\n            toggleBtn.className = 'tag-toggle';\r\n            toggleBtn.onclick = () => {\r\n                container.querySelectorAll('.hidden-tag').forEach(el => el.classList.toggle('hidden'));\r\n            };\r\n            container.appendChild(toggleBtn);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://video-player/./src/HTML.ts?");

/***/ }),

/***/ "./src/Player.ts":
/*!***********************!*\
  !*** ./src/Player.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Players {\r\n    constructor(state, html) {\r\n        this.folder = 'https://www.clipflip.online/video/';\r\n        this.muted = true;\r\n        this.playerCount = 8;\r\n        this.selectedTags = new Map();\r\n        this.state = state;\r\n        this.html = html;\r\n        // this.addFormsToPlayers();\r\n    }\r\n    async init() {\r\n        this.active = this.initializeActive(this.playerCount);\r\n        this.html.allTags = await this.fetchAllTags();\r\n        console.log('Fetched all tags:', this.html.allTags);\r\n        const toolbar = this.html.createToolbar();\r\n        const videoContainer = this.html.createVideoContainer();\r\n        document.body.appendChild(toolbar);\r\n        document.body.appendChild(videoContainer);\r\n        this.attachEventListeners();\r\n        this.initializeMuteButton();\r\n        await this.loadVideos();\r\n        this.updateLayout();\r\n        // this.addFormsToPlayers();\r\n    }\r\n    async loadVideos(active = false, reload = false) {\r\n        for (let i = 1; i <= this.html.videoPlayers.length; i++) {\r\n            console.log(`Loading video for Player ${i}...`);\r\n            if (!this.state.multiSection && i > 2) {\r\n                console.log(`Player ${i} is not active in single section mode, skipping...`);\r\n                continue;\r\n            }\r\n            if (reload && !this.html.videoPlayers[i - 1].src) {\r\n            }\r\n            else if (active && this.active && this.active[i] && this.html.videoPlayers[i - 1].src) {\r\n                console.log(`Player ${i} currently active with source, skipping...`);\r\n                continue;\r\n            }\r\n            const section = Math.ceil(i / 2);\r\n            console.log(`Loading video for Player ${i} in section ${section}`);\r\n            // get current position for that section\r\n            await this.state.modifyPosition(section);\r\n            const pos = this.state.positions[section];\r\n            console.log(`Loading video for Player ${i} at position ${pos}`);\r\n            const playerIndex = i - 1;\r\n            // assign video source based on position\r\n            this.html.videoPlayers[playerIndex].src = this.folder + pos + '.mp4';\r\n            this.html.videoPlayers[playerIndex].preload = 'auto';\r\n            const res = await this.getVideoMetadata(pos);\r\n            console.log(`Loaded metadata for video ${pos}:`, res);\r\n            this.populateMetadataForm(playerIndex, res);\r\n            // increment position for section for next video load\r\n            console.log(`first loading section ${section} position:`, this.state.positions[section]);\r\n        }\r\n    }\r\n    updateLayout() {\r\n        const isMulti = this.state.multiSection;\r\n        // Always update players 0 and 1\r\n        [0, 1].forEach(index => {\r\n            const player = this.html.videoPlayers[index];\r\n            const wrapper = player.parentElement;\r\n            // wrapper.classList.remove('hidden'); // always visible\r\n            console.log(\"Toggling player\", index + 1, \"visibility:\", !wrapper.classList.contains('half-size'));\r\n            wrapper.classList.toggle('half-size', isMulti);\r\n            console.log(`Player ${index + 1} visibility toggled to:`, !wrapper.classList.contains('half-size'));\r\n        });\r\n        this.html.videoPlayers.forEach((player, index) => {\r\n            if (index < 2)\r\n                return;\r\n            const wrapper = player.parentElement;\r\n            if (!wrapper)\r\n                return;\r\n            const shouldBeVisible = isMulti && index % 2 === 0;\r\n            if (shouldBeVisible) {\r\n                wrapper.classList.remove('hidden');\r\n            }\r\n            else {\r\n                wrapper.classList.add('hidden');\r\n            }\r\n            console.log(`${shouldBeVisible ? 'Showing' : 'Hiding'} player ${index + 1}`);\r\n        });\r\n    }\r\n    initializeMuteButton() {\r\n        var _a;\r\n        const muteIcon = document.getElementById('muteIcon');\r\n        // set initial state: all players muted + muted icon\r\n        this.html.videoPlayers.forEach(player => {\r\n            player.muted = this.muted;\r\n        });\r\n        if (muteIcon) {\r\n            muteIcon.innerHTML = `\r\n      <svg class=\"w-4 h-4 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"\r\n        viewBox=\"0 0 24 24\">\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15 9a3 3 0 010 6\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M17.5 7.5a6 6 0 010 9\" />\r\n      </svg>`;\r\n        }\r\n        // add click listener\r\n        (_a = this.html.muteToggle) === null || _a === void 0 ? void 0 : _a.addEventListener('click', () => {\r\n            this.muted = !this.muted;\r\n            this.html.videoPlayers.forEach(player => {\r\n                player.muted = this.muted;\r\n            });\r\n            muteIcon.innerHTML = !this.muted\r\n                ? `\r\n      <!-- Muted icon: speaker only -->\r\n      <svg class=\"w-4 h-4 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"\r\n        viewBox=\"0 0 24 24\">\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n      </svg>`\r\n                : `\r\n      <!-- Unmuted icon: speaker with waves -->\r\n      <svg class=\"w-4 h-4 text-gray-300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"\r\n        viewBox=\"0 0 24 24\">\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11 5L6 9H2v6h4l5 4V5z\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15 9a3 3 0 010 6\" />\r\n        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M17.5 7.5a6 6 0 010 9\" />\r\n      </svg>`;\r\n        });\r\n    }\r\n    attachEventListeners() {\r\n        this.html.playButton.addEventListener('click', async () => {\r\n            console.log('Play button clicked, playing selected videos...');\r\n            console.log('Active players:', this.active);\r\n            try {\r\n                for (let i = 0; i < this.html.videoPlayers.length; i++) {\r\n                    const player = this.html.videoPlayers[i];\r\n                    if (this.active && this.active[i + 1]) {\r\n                        console.log(`Player ${i + 1} is active, playing...`);\r\n                        await player.play();\r\n                    }\r\n                    else {\r\n                        console.log(`Player ${i + 1} is inactive, skipping...`);\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                console.error('Error playing selected videos:', error);\r\n            }\r\n        });\r\n        this.html.pauseButton.addEventListener('click', async () => {\r\n            try {\r\n                // play only videos where the player is active in state\r\n                this.html.videoPlayers\r\n                    .forEach(player => player.pause());\r\n            }\r\n            catch (error) {\r\n                console.error('Error playing selected videos:', error);\r\n            }\r\n        });\r\n        this.html.videoPlayers.forEach((player, index) => {\r\n            player.addEventListener('ended', () => {\r\n                this.handlePlayerEnded(index);\r\n            });\r\n            player.addEventListener('click', () => this.togglePlayPause(index));\r\n        });\r\n        this.html.resizeButton.addEventListener('click', () => {\r\n            console.log(\"Resizing, status:\", this.state.multiSection);\r\n            this.state.multiSection = !this.state.multiSection;\r\n            console.log(\"Resizing, new status:\", this.state.multiSection);\r\n            // this.updateResizeIcon();\r\n            this.updateLayout();\r\n            this.loadVideos(true, true);\r\n        });\r\n        this.html.fullscreenButton.addEventListener('click', () => {\r\n            this.toggleFullscreen();\r\n        });\r\n    }\r\n    initializeActive(playerCount) {\r\n        const act = {};\r\n        for (let i = 1; i < playerCount; i++) {\r\n            // active only players 1, 3, 5, 7 (odd numbers)\r\n            act[i] = (i % 2 === 1);\r\n        }\r\n        return act;\r\n    }\r\n    async getVideoMetadata(videoId) {\r\n        try {\r\n            const response = await fetch(`https://www.clipflip.online/api/videos/${videoId}`);\r\n            if (!response.ok)\r\n                throw new Error(`Failed to fetch metadata for videoId ${videoId}`);\r\n            return await response.json();\r\n        }\r\n        catch (error) {\r\n            console.error(`Error fetching metadata for videoId ${videoId}:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    async handlePlayerEnded(playerIndex) {\r\n        console.log(`Player ${playerIndex + 1} ended, switching video...`);\r\n        const section = Math.floor(playerIndex / 2) + 1;\r\n        let nextPlayerIndex = undefined;\r\n        if (playerIndex === 0) {\r\n            nextPlayerIndex = 1;\r\n        }\r\n        else if (playerIndex === 1) {\r\n            nextPlayerIndex = 0;\r\n        }\r\n        else if (playerIndex === 2) {\r\n            nextPlayerIndex = 3;\r\n        }\r\n        else if (playerIndex === 3) {\r\n            nextPlayerIndex = 2;\r\n        }\r\n        else if (playerIndex === 4) {\r\n            nextPlayerIndex = 5;\r\n        }\r\n        else if (playerIndex === 5) {\r\n            nextPlayerIndex = 4;\r\n        }\r\n        else if (playerIndex === 6) {\r\n            nextPlayerIndex = 7;\r\n        }\r\n        else if (playerIndex === 7) {\r\n            nextPlayerIndex = 6;\r\n        }\r\n        if (nextPlayerIndex === undefined) {\r\n            console.error(`Invalid player index: ${playerIndex}`);\r\n            return;\r\n        }\r\n        const primary = this.html.videoPlayers[playerIndex];\r\n        const secondary = this.html.videoPlayers[nextPlayerIndex];\r\n        await secondary.play();\r\n        this.state.modifyPosition(section);\r\n        try {\r\n            // hide/show wrappers instead of videos\r\n            const currentWrapper = primary.parentElement;\r\n            const nextWrapper = secondary.parentElement;\r\n            nextWrapper.classList.remove('hidden');\r\n            currentWrapper.classList.add('hidden');\r\n            this.active[nextPlayerIndex + 1] = !this.active[nextPlayerIndex + 1];\r\n            this.active[playerIndex + 1] = !this.active[playerIndex + 1];\r\n            console.log(this.state.positions[section], 'current position for section', section);\r\n            const pos = this.state.positions[section];\r\n            const filename = this.folder + pos + '.mp4';\r\n            primary.src = filename;\r\n            primary.preload = 'auto';\r\n            const res = await this.getVideoMetadata(pos);\r\n            this.populateMetadataForm(playerIndex, res);\r\n            // primary.load();\r\n        }\r\n        catch (err) {\r\n            console.error(`Error in section ${section}, player ${playerIndex + 1}:`, err);\r\n        }\r\n    }\r\n    togglePlayPause(index) {\r\n        const video = this.html.videoPlayers[index];\r\n        if (video.paused) {\r\n            video.play();\r\n            // this.active![index + 1] = true; // mark as active\r\n            // // hide form when playing\r\n            // const wrapper = video.parentElement;\r\n            // if (wrapper) {\r\n            //     const form = wrapper.querySelector('.form-container');\r\n            //     form?.classList.add('hidden');\r\n            // }\r\n        }\r\n        else {\r\n            video.pause();\r\n            // this.active![index + 1] = false; // mark as inactive\r\n            // // show form when paused\r\n            // const wrapper = video.parentElement;\r\n            // if (wrapper) {\r\n            //     const form = wrapper.querySelector('.form-container');\r\n            //     form?.classList.remove('hidden');\r\n            // }\r\n        }\r\n    }\r\n    async addFormsToPlayers() {\r\n        let tags = [];\r\n        try {\r\n            const response = await fetch('http://:3000/tags');\r\n            if (!response.ok)\r\n                throw new Error('Failed to fetch tags');\r\n            const bodyText = await new Response(response.body).text();\r\n            console.log(JSON.parse(bodyText));\r\n            tags = JSON.parse(bodyText);\r\n        }\r\n        catch (error) {\r\n            console.error('Error loading tags:', error);\r\n        }\r\n        for (let i = 1; i <= 8; i++) {\r\n            const wrapper = document.getElementById(`player${i}`);\r\n            if (!wrapper)\r\n                continue;\r\n            const optionsHtml = tags.length\r\n                ? tags.map(tag => `<option value=\"${tag.title}\">${tag.title}</option>`).join('')\r\n                : `...`;\r\n            console.log(tags);\r\n            const formContainer = document.createElement('div');\r\n            formContainer.className = 'form-container hidden'; // initially hidden\r\n            formContainer.innerHTML = `\r\n            <form id=\"videoForm${i}\">\r\n                <select id=\"tagSelect${i}\" multiple style=\"width: 100%;\">\r\n                    ${optionsHtml}\r\n                </select>\r\n                <input type=\"text\" id=\"videoTitle${i}\" placeholder=\"Video Title\" style=\"width: 100%; margin-top: 5px;\" />\r\n                <input type=\"text\" id=\"videoModel${i}\" placeholder=\"Model\" style=\"width: 100%; margin-top: 5px;\" />\r\n                <button type=\"submit\" class=\"submit-button\" style=\"margin-top: 5px;\">Submit</button>\r\n            </form>\r\n        `;\r\n            wrapper.appendChild(formContainer);\r\n            const form = formContainer.querySelector('form');\r\n            form === null || form === void 0 ? void 0 : form.addEventListener('submit', async (event) => {\r\n                var _a;\r\n                event.preventDefault();\r\n                const titleInput = form.querySelector(`#videoTitle${i}`);\r\n                const tagSelect = form.querySelector(`#tagSelect${i}`);\r\n                const title = (titleInput === null || titleInput === void 0 ? void 0 : titleInput.value) || '';\r\n                const tags = Array.from((tagSelect === null || tagSelect === void 0 ? void 0 : tagSelect.selectedOptions) || []).map(opt => opt.value);\r\n                const video = document.getElementById(`videoPlayer${i}`);\r\n                let videoName = '';\r\n                if (video && video.src) {\r\n                    videoName = ((_a = video.src.split('/').pop()) === null || _a === void 0 ? void 0 : _a.replace(/\\.mp4$/, '')) || '';\r\n                }\r\n                const data = {\r\n                    title,\r\n                    tags,\r\n                    id: videoName,\r\n                };\r\n                try {\r\n                    const response = await fetch('https://www.clipflip.online/api/videos', {\r\n                        method: 'POST',\r\n                        headers: { 'Content-Type': 'application/json' },\r\n                        body: JSON.stringify(data),\r\n                    });\r\n                    if (!response.ok) {\r\n                        throw new Error(`Server responded with status ${response.status}`);\r\n                    }\r\n                    console.log(`Data from player ${i} submitted successfully:`, data);\r\n                }\r\n                catch (error) {\r\n                    console.error(`Error submitting data for player ${i}:`, error);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    async toggleFullscreen() {\r\n        const doc = document;\r\n        const el = document.documentElement;\r\n        if (!doc.fullscreenElement) {\r\n            await el.requestFullscreen();\r\n        }\r\n        else {\r\n            await doc.exitFullscreen();\r\n        }\r\n    }\r\n    populateMetadataForm(index, data) {\r\n        if (!this.isMetadataValid(data) || !data) {\r\n            console.warn(`Invalid or empty metadata for Player ${index}`);\r\n            return;\r\n        }\r\n        const form = document.getElementById(`metaForm${index + 1}`);\r\n        if (!form)\r\n            return;\r\n        const inputs = form.querySelectorAll('input');\r\n        inputs.forEach((input) => {\r\n            switch (input.placeholder) {\r\n                case 'Title':\r\n                    input.value = data.title || '';\r\n                    break;\r\n                case 'Models':\r\n                    input.value = Array.isArray(data.models) ? data.models.join(', ') : (data.models || '');\r\n                    break;\r\n                case 'Studio':\r\n                    input.value = data.studio || '';\r\n                    break;\r\n            }\r\n        });\r\n        if (!data.tags || data.tags.length === 0) {\r\n            console.log(`Player ${index} has no tags.`);\r\n            return;\r\n        }\r\n        console.log(`Populating metadata form for Player ${index + 1} with data:`, data);\r\n        const tagsWrapper = this.html.tagsWrappers[index];\r\n        this.html.tagsWrappers.forEach((wrapper, i) => {\r\n            console.log(wrapper.id, 'wrapper id');\r\n        });\r\n        if (!tagsWrapper)\r\n            return;\r\n        // render toggleable tags directly here\r\n        this.html.renderTags(tagsWrapper, data.tags.map(t => t.title), index, this.toggleTag.bind(this));\r\n        // tagSelect.innerHTML = ''; // clear existing options\r\n        // const currentTag = (data.tags && data.tags.length > 0) ? data.tags[0].title : 'Select a tag';\r\n        // // add main tag as first selected option, or default text if none\r\n        // const mainOption = document.createElement('option');\r\n        // mainOption.value = currentTag;\r\n        // mainOption.textContent = currentTag || 'Select a tag';\r\n        // mainOption.selected = true;\r\n        // mainOption.disabled = false; // allow reselecting if you want\r\n        // tagSelect.appendChild(mainOption);\r\n        // // add other tags, excluding the main one to avoid duplicates\r\n        // data.tags.forEach(tag => {\r\n        //     if (tag.title !== currentTag) {\r\n        //         const option = document.createElement('option');\r\n        //         option.value = tag.title;\r\n        //         option.textContent = tag.title;\r\n        //         tagSelect.appendChild(option);\r\n        //     }\r\n        // });\r\n        // // listen for changes and update map\r\n        // tagSelect.addEventListener('change', () => {\r\n        //     const selectedTag = tagSelect.value;\r\n        //     this.html.updateMeta(index, 'tag', selectedTag); // if needed\r\n        //     this.selectedTags.set(index, selectedTag);\r\n        // });\r\n    }\r\n    async toggleTag(btn) {\r\n        var _a, _b, _c;\r\n        // find all elements with id `{tag}-id` and sync class\r\n        const tag = (_b = (_a = btn.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : '';\r\n        if (!tag)\r\n            return;\r\n        const tagId = `${tag}-id`;\r\n        // find the closest section container (e.g. player div)\r\n        const sectionEl = btn.closest('[id^=\"player\"]');\r\n        if (!sectionEl)\r\n            throw new Error(`Section element not found for tag ${tag}`);\r\n        // within that section only, find elements with the tag class and toggle\r\n        sectionEl.querySelectorAll(`.${tagId}`).forEach(el => {\r\n            if (el instanceof HTMLElement) {\r\n                el.classList.toggle('active-tag');\r\n            }\r\n        });\r\n        // Extract player number from parent id like \"player3\"\r\n        const sectionId = (_c = btn.closest('[id^=\"player\"]')) === null || _c === void 0 ? void 0 : _c.id;\r\n        const match = sectionId === null || sectionId === void 0 ? void 0 : sectionId.match(/\\d+/);\r\n        const playerNumber = match ? parseInt(match[0]) : NaN;\r\n        if (isNaN(playerNumber))\r\n            return;\r\n        const section = Math.floor(playerNumber / 2 + 1);\r\n        const tags = this.state.activeTags[section];\r\n        const isActive = btn.classList.contains('active-tag');\r\n        if (isActive && !tags.includes(tag)) {\r\n            tags.push(tag); // add tag\r\n        }\r\n        else if (!isActive && tags.includes(tag)) {\r\n            // remove tag\r\n            this.state.activeTags[section] = tags.filter((t) => t !== tag);\r\n        }\r\n        await this.loadVideos(true);\r\n    }\r\n    async fetchAllTags() {\r\n        try {\r\n            const response = await fetch('https://www.clipflip.online/api/tags', {\r\n                method: 'GET',\r\n                headers: { 'Content-Type': 'application/json' },\r\n            });\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            const tags = await response.json();\r\n            return tags; // array of tag objects\r\n        }\r\n        catch (error) {\r\n            console.error('Failed to fetch tags:', error);\r\n            return [];\r\n        }\r\n    }\r\n    isMetadataValid(data) {\r\n        var _a, _b;\r\n        if (!data)\r\n            return false;\r\n        const hasTitle = !!((_a = data.title) === null || _a === void 0 ? void 0 : _a.trim());\r\n        const hasModels = Array.isArray(data.models) && data.models.length > 0;\r\n        const hasStudio = !!((_b = data.studio) === null || _b === void 0 ? void 0 : _b.trim());\r\n        const hasTags = Array.isArray(data.tags) && data.tags.length > 0;\r\n        return hasTitle || hasModels || hasStudio || hasTags;\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Players);\r\n\n\n//# sourceURL=webpack://video-player/./src/Player.ts?");

/***/ }),

/***/ "./src/State.ts":
/*!**********************!*\
  !*** ./src/State.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass State {\r\n    constructor() {\r\n        this.randomized = true;\r\n        this.endIndex = 3873; // Maximum position index\r\n        this.positions = {\r\n            1: this.randomInRange(1, this.endIndex * 0.25),\r\n            2: this.randomInRange(this.endIndex * 0.25, this.endIndex * 0.5),\r\n            3: this.randomInRange(this.endIndex * 0.5, this.endIndex * 0.75),\r\n            4: this.randomInRange(this.endIndex * 0.75, this.endIndex)\r\n        };\r\n        this.activeTags = {\r\n            1: [\"panties\"],\r\n            2: [\"panties\"],\r\n            3: [\"panties\"],\r\n            4: [\"panties\"]\r\n        };\r\n        this.percentChance = 25; // 25% chance to modify position\r\n        this.multiSection = false; // Whether to use multiple sections\r\n        console.log(\"State initialized with positions:\", this.positions);\r\n    }\r\n    randomInRange(min, max) {\r\n        const minInt = Math.floor(min);\r\n        const maxInt = Math.floor(max);\r\n        return Math.floor(Math.random() * (maxInt - minInt + 1)) + minInt;\r\n    }\r\n    async modifyPosition(section) {\r\n        var _a;\r\n        console.log(`Modifying position for section ${section}`);\r\n        if (!(section in this.positions)) {\r\n            throw new Error(`Invalid section: ${section}`);\r\n        }\r\n        const taggedVideos = (_a = (await this.fetchVideosByTags(section))) !== null && _a !== void 0 ? _a : [];\r\n        console.log(`Tagged videos for section ${section}:`, taggedVideos);\r\n        // Tagged mode\r\n        if (taggedVideos.length > 0) {\r\n            const currentId = this.positions[section];\r\n            console.log(`Current ID for section ${section}:`, currentId);\r\n            const videoIds = taggedVideos.map(v => v.id);\r\n            ;\r\n            // Random within tagged\r\n            if (this.randomized) {\r\n                const roll = Math.random() * 100;\r\n                if (roll < this.percentChance) {\r\n                    const randomVideo = taggedVideos[Math.floor(Math.random() * taggedVideos.length)];\r\n                    console.log(`Randomly selected video for section ${section}:`, randomVideo);\r\n                    this.positions[section] = randomVideo.id;\r\n                    return;\r\n                }\r\n            }\r\n            let currentIndex = videoIds.indexOf(currentId);\r\n            console.log(`Current index in tagged list for section ${section}:`, currentIndex);\r\n            if (currentIndex === -1) {\r\n                // current not in tagged list, start from first\r\n                this.positions[section] = videoIds[0];\r\n                return;\r\n            }\r\n            console.log(\"nextIndex\", currentIndex + 1);\r\n            const nextIndex = currentIndex + 1;\r\n            if (nextIndex >= videoIds.length) {\r\n                this.positions[section] = videoIds[0];\r\n                return;\r\n            }\r\n            console.log(videoIds[nextIndex], 'next video ID for section', section);\r\n            this.positions[section] = videoIds[nextIndex];\r\n            console.log(`Next position for section ${section}:`, this.positions[section]);\r\n            return;\r\n        }\r\n        // Untagged mode\r\n        if (this.randomized) {\r\n            const roll = Math.random() * 100;\r\n            if (roll < this.percentChance) {\r\n                const newValue = Math.floor(Math.random() * this.endIndex) + 1;\r\n                this.positions[section] = newValue;\r\n                return;\r\n            }\r\n        }\r\n        const nextValue = this.positions[section] + 1 > this.endIndex ? 1 : this.positions[section] + 1;\r\n        // Default increment\r\n        this.positions[section] = nextValue;\r\n    }\r\n    async fetchVideosByTags(section) {\r\n        const tags = this.activeTags[section];\r\n        if (!tags || tags.length === 0)\r\n            return null;\r\n        try {\r\n            const response = await fetch('https://www.clipflip.online/api/videos/by-tags', {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({ tags }),\r\n            });\r\n            if (!response.ok)\r\n                throw new Error(`Server error (${response.status})`);\r\n            const videos = await response.json();\r\n            return videos;\r\n        }\r\n        catch (err) {\r\n            console.error(`Failed to fetch videos for section ${section} with tags ${tags}`, err);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (State);\r\n\n\n//# sourceURL=webpack://video-player/./src/State.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State */ \"./src/State.ts\");\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Player */ \"./src/Player.ts\");\n/* harmony import */ var _HTML__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HTML */ \"./src/HTML.ts\");\n\r\n\r\n\r\ndocument.addEventListener('DOMContentLoaded', async (e) => {\r\n    e.preventDefault();\r\n    const state = new _State__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const html = new _HTML__WEBPACK_IMPORTED_MODULE_2__[\"default\"](state);\r\n    const players = new _Player__WEBPACK_IMPORTED_MODULE_1__[\"default\"](state, html);\r\n    await players.init();\r\n    // expose for debugging or external access\r\n    window.html = html;\r\n    window.state = state;\r\n    window.players = players;\r\n});\r\n\n\n//# sourceURL=webpack://video-player/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;